{
  "address": "0xf444c08B169a838147F7E2c16e57C1b5B38702dE",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "IUniswapInteract",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "poolManager",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "IMailbox",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "IInterchainGasPayMaster",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "salt",
          "type": "bytes32"
        }
      ],
      "name": "deploy",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "uniswapInteraction",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "poolManager",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "mailBox",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "igp",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "salt",
          "type": "bytes32"
        }
      ],
      "name": "getPrecomputedHookAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "hooks",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x0bdae7b8c5bb854c59f9132662e8c47962f79c08d591b7b73e066998b608262a",
  "receipt": {
    "to": null,
    "from": "0x19d96301865fdD07427db3c445508A051BC6D352",
    "contractAddress": "0xf444c08B169a838147F7E2c16e57C1b5B38702dE",
    "transactionIndex": 2,
    "gasUsed": "4104252",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xfdc9ab8835f1923a34c6519e32a90e1420dad25455a72613654b837ec03faf37",
    "transactionHash": "0x0bdae7b8c5bb854c59f9132662e8c47962f79c08d591b7b73e066998b608262a",
    "logs": [],
    "blockNumber": 1024917,
    "cumulativeGasUsed": "4185976",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "6e146c80834829f6e55eae212bce8c8f",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"IUniswapInteract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"poolManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"IMailbox\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"IInterchainGasPayMaster\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"deploy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniswapInteraction\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"poolManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mailBox\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"igp\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"getPrecomputedHookAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"hooks\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Hooks/Utils/HooksFactory.sol\":\"UniswapHooksFactory\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/ERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC1155.sol\\\";\\nimport \\\"./IERC1155Receiver.sol\\\";\\nimport \\\"./extensions/IERC1155MetadataURI.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the basic standard multi-token.\\n * See https://eips.ethereum.org/EIPS/eip-1155\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\n *\\n * _Available since v3.1._\\n */\\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\\n    using Address for address;\\n\\n    // Mapping from token ID to account balances\\n    mapping(uint256 => mapping(address => uint256)) private _balances;\\n\\n    // Mapping from account to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\n    string private _uri;\\n\\n    /**\\n     * @dev See {_setURI}.\\n     */\\n    constructor(string memory uri_) {\\n        _setURI(uri_);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC1155).interfaceId ||\\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     *\\n     * This implementation returns the same URI for *all* token types. It relies\\n     * on the token type ID substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\n     * actual token type ID.\\n     */\\n    function uri(uint256) public view virtual override returns (string memory) {\\n        return _uri;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\\n        require(account != address(0), \\\"ERC1155: address zero is not a valid owner\\\");\\n        return _balances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] memory accounts,\\n        uint256[] memory ids\\n    ) public view virtual override returns (uint256[] memory) {\\n        require(accounts.length == ids.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not token owner or approved\\\"\\n        );\\n        _safeTransferFrom(from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not token owner or approved\\\"\\n        );\\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n        unchecked {\\n            _balances[id][from] = fromBalance - amount;\\n        }\\n        _balances[id][to] += amount;\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = _balances[id][from];\\n            require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n            unchecked {\\n                _balances[id][from] = fromBalance - amount;\\n            }\\n            _balances[id][to] += amount;\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\n     * substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\n     * clients with the token type ID.\\n     *\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\n     * interpreted by clients as\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\n     * for token type ID 0x4cce0.\\n     *\\n     * See {uri}.\\n     *\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\n     * this function emits no events.\\n     */\\n    function _setURI(string memory newuri) internal virtual {\\n        _uri = newuri;\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _balances[id][to] += amount;\\n        emit TransferSingle(operator, address(0), to, id, amount);\\n\\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][to] += amounts[i];\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `from`\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `from` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(address from, uint256 id, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC1155: burn from the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(fromBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[id][from] = fromBalance - amount;\\n        }\\n\\n        emit TransferSingle(operator, from, address(0), id, amount);\\n\\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(address from, uint256[] memory ids, uint256[] memory amounts) internal virtual {\\n        require(from != address(0), \\\"ERC1155: burn from the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = _balances[id][from];\\n            require(fromBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n            unchecked {\\n                _balances[id][from] = fromBalance - amount;\\n            }\\n        }\\n\\n        emit TransferBatch(operator, from, address(0), ids, amounts);\\n\\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\\n        require(owner != operator, \\\"ERC1155: setting approval status for self\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non-ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\\n                bytes4 response\\n            ) {\\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non-ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n\\n        return array;\\n    }\\n}\\n\",\"keccak256\":\"0x81149353c99ccf8ff18af7701bc3f38665c7a97e344cdc0d27f927f03d22af0e\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0xcab667ddad478ff0d39c2053ca77fac778af8483c18ab07d810277b4216fd582\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xeb373f1fdc7b755c6a750123a9b9e3a8a02c1470042fd6505d875000a80bde0b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0xa66d18b9a85458d28fc3304717964502ae36f7f8a2ff35bc83f6f85d74b03574\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\",\"keccak256\":\"0xa56ca923f70c1748830700250b19c61b70db9a683516dc5e216694a50445d99c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xec63854014a5b4f2b3290ab9103a21bdf902a508d0f41a8573fea49e98bf571a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\",\"keccak256\":\"0xabefac93435967b4d36a4fabcbdbb918d1f0b7ae3c3d85bc30923b326c927ed1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xd10975de010d89fd1c78dc5e8a9a7e7f496198085c151648f20cba166b32582b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.4.0;\\n\\n/// @title FixedPoint96\\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\\n/// @dev Used in SqrtPriceMath.sol\\nlibrary FixedPoint96 {\\n    uint8 internal constant RESOLUTION = 96;\\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\\n}\\n\",\"keccak256\":\"0x0ba8a9b95a956a4050749c0158e928398c447c91469682ca8a7cc7e77a7fe032\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-core/contracts/libraries/FullMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.0;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        // 512-bit multiply [prod1 prod0] = a * b\\n        // Compute the product mod 2**256 and mod 2**256 - 1\\n        // then use the Chinese Remainder Theorem to reconstruct\\n        // the 512 bit result. The result is stored in two 256\\n        // variables such that product = prod1 * 2**256 + prod0\\n        uint256 prod0; // Least significant 256 bits of the product\\n        uint256 prod1; // Most significant 256 bits of the product\\n        assembly {\\n            let mm := mulmod(a, b, not(0))\\n            prod0 := mul(a, b)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        // Handle non-overflow cases, 256 by 256 division\\n        if (prod1 == 0) {\\n            require(denominator > 0);\\n            assembly {\\n                result := div(prod0, denominator)\\n            }\\n            return result;\\n        }\\n\\n        // Make sure the result is less than 2**256.\\n        // Also prevents denominator == 0\\n        require(denominator > prod1);\\n\\n        ///////////////////////////////////////////////\\n        // 512 by 256 division.\\n        ///////////////////////////////////////////////\\n\\n        // Make division exact by subtracting the remainder from [prod1 prod0]\\n        // Compute remainder using mulmod\\n        uint256 remainder;\\n        assembly {\\n            remainder := mulmod(a, b, denominator)\\n        }\\n        // Subtract 256 bit number from 512 bit number\\n        assembly {\\n            prod1 := sub(prod1, gt(remainder, prod0))\\n            prod0 := sub(prod0, remainder)\\n        }\\n\\n        // Factor powers of two out of denominator\\n        // Compute largest power of two divisor of denominator.\\n        // Always >= 1.\\n        uint256 twos = (type(uint256).max - denominator + 1) & denominator;\\n        // Divide denominator by power of two\\n        assembly {\\n            denominator := div(denominator, twos)\\n        }\\n\\n        // Divide [prod1 prod0] by the factors of two\\n        assembly {\\n            prod0 := div(prod0, twos)\\n        }\\n        // Shift in bits from prod1 into prod0. For this we need\\n        // to flip `twos` such that it is 2**256 / twos.\\n        // If twos is zero, then it becomes one\\n        assembly {\\n            twos := add(div(sub(0, twos), twos), 1)\\n        }\\n        prod0 |= prod1 * twos;\\n\\n        // Invert denominator mod 2**256\\n        // Now that denominator is an odd number, it has an inverse\\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n        // Compute the inverse by starting with a seed that is correct\\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n        uint256 inv = (3 * denominator) ^ 2;\\n        // Now use Newton-Raphson iteration to improve the precision.\\n        // Thanks to Hensel's lifting lemma, this also works in modular\\n        // arithmetic, doubling the correct bits in each step.\\n        inv *= 2 - denominator * inv; // inverse mod 2**8\\n        inv *= 2 - denominator * inv; // inverse mod 2**16\\n        inv *= 2 - denominator * inv; // inverse mod 2**32\\n        inv *= 2 - denominator * inv; // inverse mod 2**64\\n        inv *= 2 - denominator * inv; // inverse mod 2**128\\n        inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n        // Because the division is now exact we can divide by multiplying\\n        // with the modular inverse of denominator. This will give us the\\n        // correct result modulo 2**256. Since the precoditions guarantee\\n        // that the outcome is less than 2**256, this is the final result.\\n        // We don't need to compute the high bits of the result and prod1\\n        // is no longer required.\\n        result = prod0 * inv;\\n        return result;\\n    }\\n\\n    /// @notice Calculates ceil(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        result = mulDiv(a, b, denominator);\\n        if (mulmod(a, b, denominator) > 0) {\\n            require(result < type(uint256).max);\\n            result++;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaa9d8894cfc7826e4d1abacb026b022ef4ff07569037b8796474d43257fb1f19\",\"license\":\"MIT\"},\"@uniswap/v3-core/contracts/libraries/TickMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Math library for computing sqrt prices from ticks and vice versa\\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\\n/// prices between 2**-128 and 2**128\\nlibrary TickMath {\\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\n    int24 internal constant MIN_TICK = -887272;\\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\n    int24 internal constant MAX_TICK = -MIN_TICK;\\n\\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\n    uint160 internal constant MAX_SQRT_RATIO =\\n        1461446703485210103287273052203988822378723970342;\\n\\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\\n    /// @dev Throws if |tick| > max tick\\n    /// @param tick The input tick for the above formula\\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\\n    /// at the given tick\\n    function getSqrtRatioAtTick(\\n        int24 tick\\n    ) internal pure returns (uint160 sqrtPriceX96) {\\n        uint256 absTick = tick < 0\\n            ? uint256(-int256(tick))\\n            : uint256(int256(tick));\\n        require(absTick <= uint256(uint24(MAX_TICK)), \\\"T\\\");\\n\\n        uint256 ratio = absTick & 0x1 != 0\\n            ? 0xfffcb933bd6fad37aa2d162d1a594001\\n            : 0x100000000000000000000000000000000;\\n        if (absTick & 0x2 != 0)\\n            ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\n        if (absTick & 0x4 != 0)\\n            ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n        if (absTick & 0x8 != 0)\\n            ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n        if (absTick & 0x10 != 0)\\n            ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n        if (absTick & 0x20 != 0)\\n            ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n        if (absTick & 0x40 != 0)\\n            ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n        if (absTick & 0x80 != 0)\\n            ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n        if (absTick & 0x100 != 0)\\n            ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n        if (absTick & 0x200 != 0)\\n            ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n        if (absTick & 0x400 != 0)\\n            ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n        if (absTick & 0x800 != 0)\\n            ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n        if (absTick & 0x1000 != 0)\\n            ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n        if (absTick & 0x2000 != 0)\\n            ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n        if (absTick & 0x4000 != 0)\\n            ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n        if (absTick & 0x8000 != 0)\\n            ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n        if (absTick & 0x10000 != 0)\\n            ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n        if (absTick & 0x20000 != 0)\\n            ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n        if (absTick & 0x40000 != 0)\\n            ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n        if (absTick & 0x80000 != 0)\\n            ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n\\n        if (tick > 0) ratio = type(uint256).max / ratio;\\n\\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\n        sqrtPriceX96 = uint160(\\n            (ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1)\\n        );\\n    }\\n\\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\\n    /// ever return.\\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\\n    function getTickAtSqrtRatio(\\n        uint160 sqrtPriceX96\\n    ) internal pure returns (int24 tick) {\\n        // second inequality must be < because the price can never reach the price at the max tick\\n        require(\\n            sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO,\\n            \\\"R\\\"\\n        );\\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\\n\\n        uint256 r = ratio;\\n        uint256 msb = 0;\\n\\n        assembly {\\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(5, gt(r, 0xFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(4, gt(r, 0xFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(3, gt(r, 0xFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(2, gt(r, 0xF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(1, gt(r, 0x3))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := gt(r, 0x1)\\n            msb := or(msb, f)\\n        }\\n\\n        if (msb >= 128) r = ratio >> (msb - 127);\\n        else r = ratio << (127 - msb);\\n\\n        int256 log_2 = (int256(msb) - 128) << 64;\\n\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(63, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(62, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(61, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(60, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(59, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(58, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(57, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(56, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(55, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(54, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(53, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(52, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(51, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(50, f))\\n        }\\n\\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\\n\\n        int24 tickLow = int24(\\n            (log_sqrt10001 - 3402992956809132418596140100660247210) >> 128\\n        );\\n        int24 tickHi = int24(\\n            (log_sqrt10001 + 291339464771989622907027621153398088495) >> 128\\n        );\\n\\n        tick = tickLow == tickHi\\n            ? tickLow\\n            : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96\\n            ? tickHi\\n            : tickLow;\\n    }\\n}\\n\",\"keccak256\":\"0xcb986e333c451ea768af0c528554ec367f7ffda0535a5aa402a9e1e522bcd29d\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-periphery/contracts/libraries/LiquidityAmounts.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\nimport \\\"@uniswap/v3-core/contracts/libraries/FullMath.sol\\\";\\nimport \\\"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol\\\";\\n\\n/// @title Liquidity amount functions\\n/// @notice Provides functions for computing liquidity amounts from token amounts and prices\\nlibrary LiquidityAmounts {\\n    /// @notice Downcasts uint256 to uint128\\n    /// @param x The uint258 to be downcasted\\n    /// @return y The passed value, downcasted to uint128\\n    function toUint128(uint256 x) private pure returns (uint128 y) {\\n        require((y = uint128(x)) == x);\\n    }\\n\\n    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\\n    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\n    /// @param amount0 The amount0 being sent in\\n    /// @return liquidity The amount of returned liquidity\\n    function getLiquidityForAmount0(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint256 amount0\\n    ) internal pure returns (uint128 liquidity) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96)\\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n        uint256 intermediate = FullMath.mulDiv(\\n            sqrtRatioAX96,\\n            sqrtRatioBX96,\\n            FixedPoint96.Q96\\n        );\\n        return\\n            toUint128(\\n                FullMath.mulDiv(\\n                    amount0,\\n                    intermediate,\\n                    sqrtRatioBX96 - sqrtRatioAX96\\n                )\\n            );\\n    }\\n\\n    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\\n    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\n    /// @param amount1 The amount1 being sent in\\n    /// @return liquidity The amount of returned liquidity\\n    function getLiquidityForAmount1(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint256 amount1\\n    ) internal pure returns (uint128 liquidity) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96)\\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n        return\\n            toUint128(\\n                FullMath.mulDiv(\\n                    amount1,\\n                    FixedPoint96.Q96,\\n                    sqrtRatioBX96 - sqrtRatioAX96\\n                )\\n            );\\n    }\\n\\n    /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\\n    /// pool prices and the prices at the tick boundaries\\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\n    /// @param amount0 The amount of token0 being sent in\\n    /// @param amount1 The amount of token1 being sent in\\n    /// @return liquidity The maximum amount of liquidity received\\n    function getLiquidityForAmounts(\\n        uint160 sqrtRatioX96,\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint256 amount0,\\n        uint256 amount1\\n    ) internal pure returns (uint128 liquidity) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96)\\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\\n            liquidity = getLiquidityForAmount0(\\n                sqrtRatioAX96,\\n                sqrtRatioBX96,\\n                amount0\\n            );\\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\\n            uint128 liquidity0 = getLiquidityForAmount0(\\n                sqrtRatioX96,\\n                sqrtRatioBX96,\\n                amount0\\n            );\\n            uint128 liquidity1 = getLiquidityForAmount1(\\n                sqrtRatioAX96,\\n                sqrtRatioX96,\\n                amount1\\n            );\\n\\n            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\\n        } else {\\n            liquidity = getLiquidityForAmount1(\\n                sqrtRatioAX96,\\n                sqrtRatioBX96,\\n                amount1\\n            );\\n        }\\n    }\\n\\n    /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\n    /// @param liquidity The liquidity being valued\\n    /// @return amount0 The amount of token0\\n    function getAmount0ForLiquidity(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint128 liquidity\\n    ) internal pure returns (uint256 amount0) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96)\\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n        return\\n            FullMath.mulDiv(\\n                uint256(liquidity) << FixedPoint96.RESOLUTION,\\n                sqrtRatioBX96 - sqrtRatioAX96,\\n                sqrtRatioBX96\\n            ) / sqrtRatioAX96;\\n    }\\n\\n    /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\n    /// @param liquidity The liquidity being valued\\n    /// @return amount1 The amount of token1\\n    function getAmount1ForLiquidity(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint128 liquidity\\n    ) internal pure returns (uint256 amount1) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96)\\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n        return\\n            FullMath.mulDiv(\\n                liquidity,\\n                sqrtRatioBX96 - sqrtRatioAX96,\\n                FixedPoint96.Q96\\n            );\\n    }\\n\\n    /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\\n    /// pool prices and the prices at the tick boundaries\\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\n    /// @param liquidity The liquidity being valued\\n    /// @return amount0 The amount of token0\\n    /// @return amount1 The amount of token1\\n    function getAmountsForLiquidity(\\n        uint160 sqrtRatioX96,\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint128 liquidity\\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96)\\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\\n            amount0 = getAmount0ForLiquidity(\\n                sqrtRatioAX96,\\n                sqrtRatioBX96,\\n                liquidity\\n            );\\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\\n            amount0 = getAmount0ForLiquidity(\\n                sqrtRatioX96,\\n                sqrtRatioBX96,\\n                liquidity\\n            );\\n            amount1 = getAmount1ForLiquidity(\\n                sqrtRatioAX96,\\n                sqrtRatioX96,\\n                liquidity\\n            );\\n        } else {\\n            amount1 = getAmount1ForLiquidity(\\n                sqrtRatioAX96,\\n                sqrtRatioBX96,\\n                liquidity\\n            );\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x955bc69f6e278e9dde6cdc1634d7275f1e9d02c1d81916800cdadb5d5a29f209\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.6.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nlibrary TransferHelper {\\n    /// @notice Transfers tokens from the targeted address to the given destination\\n    /// @notice Errors with 'STF' if transfer fails\\n    /// @param token The contract address of the token to be transferred\\n    /// @param from The originating address from which the tokens will be transferred\\n    /// @param to The destination address of the transfer\\n    /// @param value The amount to be transferred\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\\n    }\\n\\n    /// @notice Transfers tokens from msg.sender to a recipient\\n    /// @dev Errors with ST if transfer fails\\n    /// @param token The contract address of the token which will be transferred\\n    /// @param to The recipient of the transfer\\n    /// @param value The value of the transfer\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\\n    }\\n\\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\\n    /// @dev Errors with 'SA' if transfer fails\\n    /// @param token The contract address of the token to be approved\\n    /// @param to The target of the approval\\n    /// @param value The amount of the given token the target will be allowed to spend\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\\n    }\\n\\n    /// @notice Transfers ETH to the recipient address\\n    /// @dev Fails with `STE`\\n    /// @param to The destination of the transfer\\n    /// @param value The value to be transferred\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'STE');\\n    }\\n}\\n\",\"keccak256\":\"0x9af98b0908c96320ca6d08b22f0efca864742f6adbe5794cafe2d1d2e808b0cd\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/Fees.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.19;\\n\\nimport {Currency, CurrencyLibrary} from \\\"./types/Currency.sol\\\";\\nimport {IProtocolFeeController} from \\\"./interfaces/IProtocolFeeController.sol\\\";\\nimport {IHookFeeManager} from \\\"./interfaces/IHookFeeManager.sol\\\";\\nimport {IFees} from \\\"./interfaces/IFees.sol\\\";\\nimport {FeeLibrary} from \\\"./libraries/FeeLibrary.sol\\\";\\nimport {Pool} from \\\"./libraries/Pool.sol\\\";\\nimport {PoolKey} from \\\"./types/PoolKey.sol\\\";\\nimport {Owned} from \\\"./Owned.sol\\\";\\n\\nabstract contract Fees is IFees, Owned {\\n    using FeeLibrary for uint24;\\n    using CurrencyLibrary for Currency;\\n\\n    uint8 public constant MIN_PROTOCOL_FEE_DENOMINATOR = 4;\\n\\n    mapping(Currency currency => uint256) public protocolFeesAccrued;\\n\\n    mapping(address hookAddress => mapping(Currency currency => uint256)) public hookFeesAccrued;\\n\\n    IProtocolFeeController public protocolFeeController;\\n\\n    uint256 private immutable controllerGasLimit;\\n\\n    constructor(uint256 _controllerGasLimit) {\\n        controllerGasLimit = _controllerGasLimit;\\n    }\\n\\n    function _fetchProtocolFees(PoolKey memory key) internal view returns (uint24 protocolFees) {\\n        uint16 protocolSwapFee;\\n        uint16 protocolWithdrawFee;\\n        if (address(protocolFeeController) != address(0)) {\\n            // note that EIP-150 mandates that calls requesting more than 63/64ths of remaining gas\\n            // will be allotted no more than this amount, so controllerGasLimit must be set with this\\n            // in mind.\\n            if (gasleft() < controllerGasLimit) revert ProtocolFeeCannotBeFetched();\\n            try protocolFeeController.protocolFeesForPool{gas: controllerGasLimit}(key) returns (\\n                uint24 updatedProtocolFees\\n            ) {\\n                protocolSwapFee = uint16(updatedProtocolFees >> 12);\\n                protocolWithdrawFee = uint16(updatedProtocolFees & 0xFFF);\\n\\n                protocolFees = updatedProtocolFees;\\n            } catch {}\\n            _checkProtocolFee(protocolSwapFee);\\n            _checkProtocolFee(protocolWithdrawFee);\\n        }\\n    }\\n\\n    /// @notice There is no cap on the hook fee, but it is specified as a percentage taken on the amount after the protocol fee is applied, if there is a protocol fee.\\n    function _fetchHookFees(PoolKey memory key) internal view returns (uint24 hookFees) {\\n        if (address(key.hooks) != address(0)) {\\n            try IHookFeeManager(address(key.hooks)).getHookFees(key) returns (uint24 hookFeesRaw) {\\n                uint24 swapFeeMask = key.fee.hasHookSwapFee() ? 0xFFF000 : 0;\\n                uint24 withdrawFeeMask = key.fee.hasHookWithdrawFee() ? 0xFFF : 0;\\n                uint24 fullFeeMask = swapFeeMask | withdrawFeeMask;\\n                hookFees = hookFeesRaw & fullFeeMask;\\n            } catch {}\\n        }\\n    }\\n\\n    /// @dev Only the lower 12 bits are used here to encode the fee denominator.\\n    function _checkProtocolFee(uint16 fee) internal pure {\\n        if (fee != 0) {\\n            uint16 fee0 = fee % 64;\\n            uint16 fee1 = fee >> 6;\\n            // The fee is specified as a denominator so it cannot be LESS than the MIN_PROTOCOL_FEE_DENOMINATOR (unless it is 0).\\n            if (\\n                (fee0 != 0 && fee0 < MIN_PROTOCOL_FEE_DENOMINATOR) || (fee1 != 0 && fee1 < MIN_PROTOCOL_FEE_DENOMINATOR)\\n            ) {\\n                revert FeeTooLarge();\\n            }\\n        }\\n    }\\n\\n    function setProtocolFeeController(IProtocolFeeController controller) external onlyOwner {\\n        protocolFeeController = controller;\\n        emit ProtocolFeeControllerUpdated(address(controller));\\n    }\\n\\n    function collectProtocolFees(address recipient, Currency currency, uint256 amount)\\n        external\\n        returns (uint256 amountCollected)\\n    {\\n        if (msg.sender != owner && msg.sender != address(protocolFeeController)) revert InvalidCaller();\\n\\n        amountCollected = (amount == 0) ? protocolFeesAccrued[currency] : amount;\\n        protocolFeesAccrued[currency] -= amountCollected;\\n        currency.transfer(recipient, amountCollected);\\n    }\\n\\n    function collectHookFees(address recipient, Currency currency, uint256 amount)\\n        external\\n        returns (uint256 amountCollected)\\n    {\\n        address hookAddress = msg.sender;\\n\\n        amountCollected = (amount == 0) ? hookFeesAccrued[hookAddress][currency] : amount;\\n        recipient = (recipient == address(0)) ? hookAddress : recipient;\\n\\n        hookFeesAccrued[hookAddress][currency] -= amountCollected;\\n        currency.transfer(recipient, amountCollected);\\n    }\\n}\\n\",\"keccak256\":\"0xec3ad6bfcf6dd2cd9625d240aee8bb239c193ef8c9889811f985576040268ebe\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/NoDelegateCall.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.20;\\n\\n/// @title Prevents delegatecall to a contract\\n/// @notice Base contract that provides a modifier for preventing delegatecall to methods in a child contract\\nabstract contract NoDelegateCall {\\n    error DelegateCallNotAllowed();\\n\\n    /// @dev The original address of this contract\\n    address private immutable original;\\n\\n    constructor() {\\n        // Immutables are computed in the init code of the contract, and then inlined into the deployed bytecode.\\n        // In other words, this variable won't change when it's checked at runtime.\\n        original = address(this);\\n    }\\n\\n    /// @dev Private method is used instead of inlining into modifier because modifiers are copied into each method,\\n    ///     and the use of immutable means the address bytes are copied in every place the modifier is used.\\n    function checkNotDelegateCall() private view {\\n        if (address(this) != original) revert DelegateCallNotAllowed();\\n    }\\n\\n    /// @notice Prevents delegatecall into the modified method\\n    modifier noDelegateCall() {\\n        checkNotDelegateCall();\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0xf17b8cb46d679529ffd7b8f33e35190e9df7dc6b41da11dcf7b1ba134e8d0c40\",\"license\":\"BUSL-1.1\"},\"@uniswap/v4-core/contracts/Owned.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.20;\\n\\ncontract Owned {\\n    address public owner;\\n    bytes12 private STORAGE_PLACEHOLDER;\\n\\n    error InvalidCaller();\\n\\n    /// @notice Emitted when the owner of the factory is changed\\n    /// @param oldOwner The owner before the owner was changed\\n    /// @param newOwner The owner after the owner was changed\\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\\n\\n    modifier onlyOwner() {\\n        if (msg.sender != owner) revert InvalidCaller();\\n        _;\\n    }\\n\\n    constructor() {\\n        owner = msg.sender;\\n        emit OwnerChanged(address(0), msg.sender);\\n    }\\n\\n    function setOwner(address _owner) external onlyOwner {\\n        emit OwnerChanged(owner, _owner);\\n        owner = _owner;\\n    }\\n}\\n\",\"keccak256\":\"0x0109d375f0df894818365069e711e88bb8b6b315a867cac951f22bafeedacd64\",\"license\":\"BUSL-1.1\"},\"@uniswap/v4-core/contracts/PoolManager.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.20;\\n\\nimport {Hooks} from './libraries/Hooks.sol';\\nimport {Pool} from './libraries/Pool.sol';\\nimport {SafeCast} from './libraries/SafeCast.sol';\\nimport {Position} from './libraries/Position.sol';\\nimport {FeeLibrary} from './libraries/FeeLibrary.sol';\\nimport {Currency, CurrencyLibrary} from './types/Currency.sol';\\nimport {PoolKey} from './types/PoolKey.sol';\\nimport {LockDataLibrary} from './libraries/LockDataLibrary.sol';\\nimport {NoDelegateCall} from './NoDelegateCall.sol';\\nimport {Owned} from './Owned.sol';\\nimport {IHooks} from './interfaces/IHooks.sol';\\nimport {IDynamicFeeManager} from './interfaces/IDynamicFeeManager.sol';\\nimport {IHookFeeManager} from './interfaces/IHookFeeManager.sol';\\nimport {IPoolManager} from './interfaces/IPoolManager.sol';\\nimport {ILockCallback} from './interfaces/callback/ILockCallback.sol';\\nimport {Fees} from './Fees.sol';\\nimport {ERC1155} from '@openzeppelin/contracts/token/ERC1155/ERC1155.sol';\\nimport {IERC1155Receiver} from '@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol';\\nimport {PoolId, PoolIdLibrary} from './types/PoolId.sol';\\nimport {BalanceDelta} from './types/BalanceDelta.sol';\\nimport 'hardhat/console.sol';\\n\\n/// @notice Holds the state for all pools\\ncontract PoolManager is IPoolManager, Fees, NoDelegateCall, ERC1155, IERC1155Receiver {\\n    using PoolIdLibrary for PoolKey;\\n    using SafeCast for *;\\n    using Pool for *;\\n    using Hooks for IHooks;\\n    using Position for mapping(bytes32 => Position.Info);\\n    using CurrencyLibrary for Currency;\\n    using LockDataLibrary for IPoolManager.LockData;\\n    using FeeLibrary for uint24;\\n\\n    /// @inheritdoc IPoolManager\\n    int24 public constant override MAX_TICK_SPACING = type(int16).max;\\n\\n    /// @inheritdoc IPoolManager\\n    int24 public constant override MIN_TICK_SPACING = 1;\\n\\n    /// @inheritdoc IPoolManager\\n    IPoolManager.LockData public override lockData;\\n\\n    /// @dev Represents the currencies due/owed to each locker.\\n    /// Must all net to zero when the last lock is released.\\n    mapping(address locker => mapping(Currency currency => int256 currencyDelta)) public currencyDelta;\\n\\n    /// @inheritdoc IPoolManager\\n    mapping(Currency currency => uint256) public override reservesOf;\\n\\n    mapping(PoolId id => Pool.State) public pools;\\n\\n    constructor(uint256 controllerGasLimit) Fees(controllerGasLimit) ERC1155('') {}\\n\\n    function _getPool(PoolKey memory key) private view returns (Pool.State storage) {\\n        return pools[key.toId()];\\n    }\\n\\n    /// @inheritdoc IPoolManager\\n    function getSlot0(\\n        PoolId id\\n    ) external view override returns (uint160 sqrtPriceX96, int24 tick, uint24 protocolFees, uint24 hookFees) {\\n        Pool.Slot0 memory slot0 = pools[id].slot0;\\n\\n        return (slot0.sqrtPriceX96, slot0.tick, slot0.protocolFees, slot0.hookFees);\\n    }\\n\\n    /// @inheritdoc IPoolManager\\n    function getLiquidity(PoolId id) external view override returns (uint128 liquidity) {\\n        return pools[id].liquidity;\\n    }\\n\\n    /// @inheritdoc IPoolManager\\n    function getLiquidity(\\n        PoolId id,\\n        address _owner,\\n        int24 tickLower,\\n        int24 tickUpper\\n    ) external view override returns (uint128 liquidity) {\\n        return pools[id].positions.get(_owner, tickLower, tickUpper).liquidity;\\n    }\\n\\n    function getPosition(\\n        PoolId id,\\n        address owner,\\n        int24 tickLower,\\n        int24 tickUpper\\n    ) external view override returns (Position.Info memory position) {\\n        return pools[id].positions.get(owner, tickLower, tickUpper);\\n    }\\n\\n    /// @inheritdoc IPoolManager\\n    function getLock(uint256 i) external view override returns (address locker) {\\n        return LockDataLibrary.getLock(i);\\n    }\\n\\n    /// @inheritdoc IPoolManager\\n    function initialize(\\n        PoolKey memory key,\\n        uint160 sqrtPriceX96,\\n        bytes calldata hookData\\n    ) external override returns (int24 tick) {\\n        if (key.fee.isStaticFeeTooLarge()) revert FeeTooLarge();\\n\\n        // see TickBitmap.sol for overflow conditions that can arise from tick spacing being too large\\n        if (key.tickSpacing > MAX_TICK_SPACING) revert TickSpacingTooLarge();\\n        if (key.tickSpacing < MIN_TICK_SPACING) revert TickSpacingTooSmall();\\n        if (key.currency0 > key.currency1) revert CurrenciesInitializedOutOfOrder();\\n        if (!key.hooks.isValidHookAddress(key.fee)) revert Hooks.HookAddressNotValid(address(key.hooks));\\n        console.log('Hello!');\\n        if (key.hooks.shouldCallBeforeInitialize()) {\\n            console.log('Hello!');\\n\\n            if (\\n                key.hooks.beforeInitialize(msg.sender, key, sqrtPriceX96, hookData) != IHooks.beforeInitialize.selector\\n            ) {\\n                revert Hooks.InvalidHookResponse();\\n            }\\n        }\\n\\n        PoolId id = key.toId();\\n        uint24 protocolFees = _fetchProtocolFees(key);\\n        uint24 hookFees = _fetchHookFees(key);\\n        tick = pools[id].initialize(sqrtPriceX96, protocolFees, hookFees);\\n\\n        if (key.hooks.shouldCallAfterInitialize()) {\\n            if (\\n                key.hooks.afterInitialize(msg.sender, key, sqrtPriceX96, tick, hookData) !=\\n                IHooks.afterInitialize.selector\\n            ) {\\n                revert Hooks.InvalidHookResponse();\\n            }\\n        }\\n\\n        emit Initialize(id, key.currency0, key.currency1, key.fee, key.tickSpacing, key.hooks);\\n    }\\n\\n    /// @inheritdoc IPoolManager\\n    function lock(bytes calldata data) external override returns (bytes memory result) {\\n        lockData.push(msg.sender);\\n\\n        // the caller does everything in this callback, including paying what they owe via calls to settle\\n        result = ILockCallback(msg.sender).lockAcquired(data);\\n\\n        if (lockData.length == 1) {\\n            if (lockData.nonzeroDeltaCount != 0) revert CurrencyNotSettled();\\n            delete lockData;\\n        } else {\\n            lockData.pop();\\n        }\\n    }\\n\\n    function _accountDelta(Currency currency, int128 delta) internal {\\n        if (delta == 0) return;\\n\\n        address locker = lockData.getActiveLock();\\n        int256 current = currencyDelta[locker][currency];\\n        int256 next = current + delta;\\n\\n        unchecked {\\n            if (next == 0) {\\n                lockData.nonzeroDeltaCount--;\\n            } else if (current == 0) {\\n                lockData.nonzeroDeltaCount++;\\n            }\\n        }\\n\\n        currencyDelta[locker][currency] = next;\\n    }\\n\\n    /// @dev Accumulates a balance change to a map of currency to balance changes\\n    function _accountPoolBalanceDelta(PoolKey memory key, BalanceDelta delta) internal {\\n        _accountDelta(key.currency0, delta.amount0());\\n        _accountDelta(key.currency1, delta.amount1());\\n    }\\n\\n    modifier onlyByLocker() {\\n        address locker = lockData.getActiveLock();\\n        if (msg.sender != locker) revert LockedBy(locker);\\n        _;\\n    }\\n\\n    /// @inheritdoc IPoolManager\\n    function modifyPosition(\\n        PoolKey memory key,\\n        IPoolManager.ModifyPositionParams memory params,\\n        bytes calldata hookData\\n    ) external override noDelegateCall onlyByLocker returns (BalanceDelta delta) {\\n        if (key.hooks.shouldCallBeforeModifyPosition()) {\\n            if (\\n                key.hooks.beforeModifyPosition(msg.sender, key, params, hookData) !=\\n                IHooks.beforeModifyPosition.selector\\n            ) {\\n                revert Hooks.InvalidHookResponse();\\n            }\\n        }\\n\\n        PoolId id = key.toId();\\n        Pool.FeeAmounts memory feeAmounts;\\n        (delta, feeAmounts) = pools[id].modifyPosition(\\n            Pool.ModifyPositionParams({\\n                owner: msg.sender,\\n                tickLower: params.tickLower,\\n                tickUpper: params.tickUpper,\\n                liquidityDelta: params.liquidityDelta.toInt128(),\\n                tickSpacing: key.tickSpacing\\n            })\\n        );\\n\\n        _accountPoolBalanceDelta(key, delta);\\n\\n        unchecked {\\n            if (feeAmounts.feeForProtocol0 > 0) {\\n                protocolFeesAccrued[key.currency0] += feeAmounts.feeForProtocol0;\\n            }\\n            if (feeAmounts.feeForProtocol1 > 0) {\\n                protocolFeesAccrued[key.currency1] += feeAmounts.feeForProtocol1;\\n            }\\n            if (feeAmounts.feeForHook0 > 0) {\\n                hookFeesAccrued[address(key.hooks)][key.currency0] += feeAmounts.feeForHook0;\\n            }\\n            if (feeAmounts.feeForHook1 > 0) {\\n                hookFeesAccrued[address(key.hooks)][key.currency1] += feeAmounts.feeForHook1;\\n            }\\n        }\\n\\n        if (key.hooks.shouldCallAfterModifyPosition()) {\\n            if (\\n                key.hooks.afterModifyPosition(msg.sender, key, params, delta, hookData) !=\\n                IHooks.afterModifyPosition.selector\\n            ) {\\n                revert Hooks.InvalidHookResponse();\\n            }\\n        }\\n\\n        emit ModifyPosition(id, msg.sender, params.tickLower, params.tickUpper, params.liquidityDelta);\\n    }\\n\\n    /// @inheritdoc IPoolManager\\n    function swap(\\n        PoolKey memory key,\\n        IPoolManager.SwapParams memory params,\\n        bytes calldata hookData\\n    ) external override noDelegateCall onlyByLocker returns (BalanceDelta delta) {\\n        if (key.hooks.shouldCallBeforeSwap()) {\\n            if (key.hooks.beforeSwap(msg.sender, key, params, hookData) != IHooks.beforeSwap.selector) {\\n                revert Hooks.InvalidHookResponse();\\n            }\\n        }\\n        // Set the total swap fee, either through the hook or as the static fee set an initialization.\\n        uint24 totalSwapFee;\\n        if (key.fee.isDynamicFee()) {\\n            totalSwapFee = IDynamicFeeManager(address(key.hooks)).getFee(msg.sender, key, params, hookData);\\n            if (totalSwapFee >= 1000000) revert FeeTooLarge();\\n        } else {\\n            // clear the top 4 bits since they may be flagged for hook fees\\n            totalSwapFee = key.fee.getStaticFee();\\n        }\\n\\n        uint256 feeForProtocol;\\n        uint256 feeForHook;\\n        Pool.SwapState memory state;\\n        PoolId id = key.toId();\\n        (delta, feeForProtocol, feeForHook, state) = pools[id].swap(\\n            Pool.SwapParams({\\n                fee: totalSwapFee,\\n                tickSpacing: key.tickSpacing,\\n                zeroForOne: params.zeroForOne,\\n                amountSpecified: params.amountSpecified,\\n                sqrtPriceLimitX96: params.sqrtPriceLimitX96\\n            })\\n        );\\n\\n        _accountPoolBalanceDelta(key, delta);\\n        // the fee is on the input currency\\n\\n        unchecked {\\n            if (feeForProtocol > 0) {\\n                protocolFeesAccrued[params.zeroForOne ? key.currency0 : key.currency1] += feeForProtocol;\\n            }\\n            if (feeForHook > 0) {\\n                hookFeesAccrued[address(key.hooks)][params.zeroForOne ? key.currency0 : key.currency1] += feeForHook;\\n            }\\n        }\\n\\n        if (key.hooks.shouldCallAfterSwap()) {\\n            if (key.hooks.afterSwap(msg.sender, key, params, delta, hookData) != IHooks.afterSwap.selector) {\\n                revert Hooks.InvalidHookResponse();\\n            }\\n        }\\n\\n        emit Swap(\\n            id,\\n            msg.sender,\\n            delta.amount0(),\\n            delta.amount1(),\\n            state.sqrtPriceX96,\\n            state.liquidity,\\n            state.tick,\\n            totalSwapFee\\n        );\\n    }\\n\\n    /// @inheritdoc IPoolManager\\n    function donate(\\n        PoolKey memory key,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes calldata hookData\\n    ) external override noDelegateCall onlyByLocker returns (BalanceDelta delta) {\\n        if (key.hooks.shouldCallBeforeDonate()) {\\n            if (key.hooks.beforeDonate(msg.sender, key, amount0, amount1, hookData) != IHooks.beforeDonate.selector) {\\n                revert Hooks.InvalidHookResponse();\\n            }\\n        }\\n\\n        delta = _getPool(key).donate(amount0, amount1);\\n\\n        _accountPoolBalanceDelta(key, delta);\\n\\n        if (key.hooks.shouldCallAfterDonate()) {\\n            if (key.hooks.afterDonate(msg.sender, key, amount0, amount1, hookData) != IHooks.afterDonate.selector) {\\n                revert Hooks.InvalidHookResponse();\\n            }\\n        }\\n    }\\n\\n    /// @inheritdoc IPoolManager\\n    function take(Currency currency, address to, uint256 amount) external override noDelegateCall onlyByLocker {\\n        _accountDelta(currency, amount.toInt128());\\n        reservesOf[currency] -= amount;\\n        currency.transfer(to, amount);\\n    }\\n\\n    /// @inheritdoc IPoolManager\\n    function mint(Currency currency, address to, uint256 amount) external override noDelegateCall onlyByLocker {\\n        _accountDelta(currency, amount.toInt128());\\n        _mint(to, currency.toId(), amount, '');\\n    }\\n\\n    /// @inheritdoc IPoolManager\\n    function settle(Currency currency) external payable override noDelegateCall onlyByLocker returns (uint256 paid) {\\n        uint256 reservesBefore = reservesOf[currency];\\n        reservesOf[currency] = currency.balanceOfSelf();\\n        paid = reservesOf[currency] - reservesBefore;\\n        // subtraction must be safe\\n        _accountDelta(currency, -(paid.toInt128()));\\n    }\\n\\n    function _burnAndAccount(Currency currency, uint256 amount) internal {\\n        _burn(address(this), currency.toId(), amount);\\n        _accountDelta(currency, -(amount.toInt128()));\\n    }\\n\\n    function onERC1155Received(address, address, uint256 id, uint256 value, bytes calldata) external returns (bytes4) {\\n        if (msg.sender != address(this)) revert NotPoolManagerToken();\\n        _burnAndAccount(CurrencyLibrary.fromId(id), value);\\n        return IERC1155Receiver.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata\\n    ) external returns (bytes4) {\\n        if (msg.sender != address(this)) revert NotPoolManagerToken();\\n        // unchecked to save gas on incrementations of i\\n        unchecked {\\n            for (uint256 i; i < ids.length; i++) {\\n                _burnAndAccount(CurrencyLibrary.fromId(ids[i]), values[i]);\\n            }\\n        }\\n        return IERC1155Receiver.onERC1155BatchReceived.selector;\\n    }\\n\\n    function setProtocolFees(PoolKey memory key) external {\\n        uint24 newProtocolFees = _fetchProtocolFees(key);\\n        PoolId id = key.toId();\\n        pools[id].setProtocolFees(newProtocolFees);\\n        emit ProtocolFeeUpdated(id, newProtocolFees);\\n    }\\n\\n    function setHookFees(PoolKey memory key) external {\\n        uint24 newHookFees = _fetchHookFees(key);\\n        PoolId id = key.toId();\\n        pools[id].setHookFees(newHookFees);\\n        emit HookFeeUpdated(id, newHookFees);\\n    }\\n\\n    function extsload(bytes32 slot) external view returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            value := sload(slot)\\n        }\\n    }\\n\\n    function extsload(bytes32 startSlot, uint256 nSlots) external view returns (bytes memory) {\\n        bytes memory value = new bytes(32 * nSlots);\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {\\n                let i := 0\\n            } lt(i, nSlots) {\\n                i := add(i, 1)\\n            } {\\n                mstore(add(value, mul(add(i, 1), 32)), sload(add(startSlot, i)))\\n            }\\n        }\\n\\n        return value;\\n    }\\n\\n    /// @notice receive native tokens for native pools\\n    receive() external payable {}\\n}\\n\",\"keccak256\":\"0xffd300aa147163b91766f9b5443a2c897c651e24e8e1d1e408cb38fa9b374c47\",\"license\":\"BUSL-1.1\"},\"@uniswap/v4-core/contracts/interfaces/IDynamicFeeManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {PoolKey} from \\\"../types/PoolKey.sol\\\";\\nimport {IPoolManager} from \\\"./IPoolManager.sol\\\";\\n\\n/// @notice The dynamic fee manager determines fees for pools\\n/// @dev note that this pool is only called if the PoolKey fee value is equal to the DYNAMIC_FEE magic value\\ninterface IDynamicFeeManager {\\n    function getFee(address sender, PoolKey calldata key, IPoolManager.SwapParams calldata params, bytes calldata data)\\n        external\\n        returns (uint24);\\n}\\n\",\"keccak256\":\"0x025e7eb045536c46bb83e95cad52dea1c3ea9b9410c1f0588131b21e322b53d6\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/interfaces/IFees.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.19;\\n\\nimport {Currency} from \\\"../types/Currency.sol\\\";\\n\\ninterface IFees {\\n    /// @notice Thrown when the protocol fee denominator is less than 4. Also thrown when the static or dynamic fee on a pool is exceeds 100%.\\n    error FeeTooLarge();\\n    /// @notice Thrown when not enough gas is provided to look up the protocol fee\\n    error ProtocolFeeCannotBeFetched();\\n\\n    event ProtocolFeeControllerUpdated(address protocolFeeController);\\n\\n    /// @notice Returns the minimum denominator for the protocol fee, which restricts it to a maximum of 25%\\n    function MIN_PROTOCOL_FEE_DENOMINATOR() external view returns (uint8);\\n\\n    /// @notice Given a currency address, returns the protocol fees accrued in that currency\\n    function protocolFeesAccrued(Currency) external view returns (uint256);\\n\\n    /// @notice Given a hook and a currency address, returns the fees accrued\\n    function hookFeesAccrued(address, Currency) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x2fb66160acff9b1a6031e3ada15e4271b25399d6b921dc17679cde1e50f566e2\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/interfaces/IHookFeeManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {PoolKey} from \\\"../types/PoolKey.sol\\\";\\n\\n/// @notice The interface for setting a fee on swap or fee on withdraw to the hook\\n/// @dev This callback is only made if the Fee.HOOK_SWAP_FEE_FLAG or Fee.HOOK_WITHDRAW_FEE_FLAG in set in the pool's key.fee.\\ninterface IHookFeeManager {\\n    /// @notice Gets the fee a hook can take at swap/withdraw. Upper bits used for swap and lower bits for withdraw.\\n    /// @param key The pool key\\n    /// @return The hook fees for swapping (upper bits set) and withdrawing (lower bits set).\\n    function getHookFees(PoolKey calldata key) external view returns (uint24);\\n}\\n\",\"keccak256\":\"0x0cbf84e24794abd7c1659f74f88fb41b78dc7483d082fc409c570197c850a97d\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/interfaces/IHooks.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {PoolKey} from \\\"../types/PoolKey.sol\\\";\\nimport {BalanceDelta} from \\\"../types/BalanceDelta.sol\\\";\\nimport {IPoolManager} from \\\"./IPoolManager.sol\\\";\\n\\n/// @notice The PoolManager contract decides whether to invoke specific hooks by inspecting the leading bits\\n/// of the hooks contract address. For example, a 1 bit in the first bit of the address will\\n/// cause the 'before swap' hook to be invoked. See the Hooks library for the full spec.\\n/// @dev Should only be callable by the v4 PoolManager.\\ninterface IHooks {\\n    /// @notice The hook called before the state of a pool is initialized\\n    /// @param sender The initial msg.sender for the initialize call\\n    /// @param key The key for the pool being initialized\\n    /// @param sqrtPriceX96 The sqrt(price) of the pool as a Q64.96\\n    /// @param hookData Arbitrary data handed into the PoolManager by the initializer to be be passed on to the hook\\n    /// @return bytes4 The function selector for the hook\\n    function beforeInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96, bytes calldata hookData)\\n        external\\n        returns (bytes4);\\n\\n    /// @notice The hook called after the state of a pool is initialized\\n    /// @param sender The initial msg.sender for the initialize call\\n    /// @param key The key for the pool being initialized\\n    /// @param sqrtPriceX96 The sqrt(price) of the pool as a Q64.96\\n    /// @param tick The current tick after the state of a pool is initialized\\n    /// @param hookData Arbitrary data handed into the PoolManager by the initializer to be be passed on to the hook\\n    /// @return bytes4 The function selector for the hook\\n    function afterInitialize(\\n        address sender,\\n        PoolKey calldata key,\\n        uint160 sqrtPriceX96,\\n        int24 tick,\\n        bytes calldata hookData\\n    ) external returns (bytes4);\\n\\n    /// @notice The hook called before a position is modified\\n    /// @param sender The initial msg.sender for the modify position call\\n    /// @param key The key for the pool\\n    /// @param params The parameters for modifying the position\\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidty provider to be be passed on to the hook\\n    /// @return bytes4 The function selector for the hook\\n    function beforeModifyPosition(\\n        address sender,\\n        PoolKey calldata key,\\n        IPoolManager.ModifyPositionParams calldata params,\\n        bytes calldata hookData\\n    ) external returns (bytes4);\\n\\n    /// @notice The hook called after a position is modified\\n    /// @param sender The initial msg.sender for the modify position call\\n    /// @param key The key for the pool\\n    /// @param params The parameters for modifying the position\\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidty provider to be be passed on to the hook\\n    /// @return bytes4 The function selector for the hook\\n    function afterModifyPosition(\\n        address sender,\\n        PoolKey calldata key,\\n        IPoolManager.ModifyPositionParams calldata params,\\n        BalanceDelta delta,\\n        bytes calldata hookData\\n    ) external returns (bytes4);\\n\\n    /// @notice The hook called before a swap\\n    /// @param sender The initial msg.sender for the swap call\\n    /// @param key The key for the pool\\n    /// @param params The parameters for the swap\\n    /// @param hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook\\n    /// @return bytes4 The function selector for the hook\\n    function beforeSwap(\\n        address sender,\\n        PoolKey calldata key,\\n        IPoolManager.SwapParams calldata params,\\n        bytes calldata hookData\\n    ) external returns (bytes4);\\n\\n    /// @notice The hook called after a swap\\n    /// @param sender The initial msg.sender for the swap call\\n    /// @param key The key for the pool\\n    /// @param params The parameters for the swap\\n    /// @param delta The amount owed to the locker (positive) or owed to the pool (negative)\\n    /// @param hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook\\n    /// @return bytes4 The function selector for the hook\\n    function afterSwap(\\n        address sender,\\n        PoolKey calldata key,\\n        IPoolManager.SwapParams calldata params,\\n        BalanceDelta delta,\\n        bytes calldata hookData\\n    ) external returns (bytes4);\\n\\n    /// @notice The hook called before donate\\n    /// @param sender The initial msg.sender for the donate call\\n    /// @param key The key for the pool\\n    /// @param amount0 The amount of token0 being donated\\n    /// @param amount1 The amount of token1 being donated\\n    /// @param hookData Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook\\n    /// @return bytes4 The function selector for the hook\\n    function beforeDonate(\\n        address sender,\\n        PoolKey calldata key,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes calldata hookData\\n    ) external returns (bytes4);\\n\\n    /// @notice The hook called after donate\\n    /// @param sender The initial msg.sender for the donate call\\n    /// @param key The key for the pool\\n    /// @param amount0 The amount of token0 being donated\\n    /// @param amount1 The amount of token1 being donated\\n    /// @param hookData Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook\\n    /// @return bytes4 The function selector for the hook\\n    function afterDonate(\\n        address sender,\\n        PoolKey calldata key,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes calldata hookData\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0x7263c9c8fef8b2346bebfd67956b287666a8c9e1f74131789650af4945ba4523\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/interfaces/IPoolManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {Currency} from \\\"../types/Currency.sol\\\";\\nimport {PoolKey} from \\\"../types/PoolKey.sol\\\";\\nimport {Pool} from \\\"../libraries/Pool.sol\\\";\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport {IHooks} from \\\"./IHooks.sol\\\";\\nimport {IFees} from \\\"./IFees.sol\\\";\\nimport {BalanceDelta} from \\\"../types/BalanceDelta.sol\\\";\\nimport {PoolId} from \\\"../types/PoolId.sol\\\";\\nimport {Position} from \\\"../libraries/Position.sol\\\";\\n\\ninterface IPoolManager is IFees, IERC1155 {\\n    /// @notice Thrown when currencies touched has exceeded max of 256\\n    error MaxCurrenciesTouched();\\n\\n    /// @notice Thrown when a currency is not netted out after a lock\\n    error CurrencyNotSettled();\\n\\n    /// @notice Thrown when a function is called by an address that is not the current locker\\n    /// @param locker The current locker\\n    error LockedBy(address locker);\\n\\n    /// @notice The ERC1155 being deposited is not the Uniswap ERC1155\\n    error NotPoolManagerToken();\\n\\n    /// @notice Pools are limited to type(int16).max tickSpacing in #initialize, to prevent overflow\\n    error TickSpacingTooLarge();\\n    /// @notice Pools must have a positive non-zero tickSpacing passed to #initialize\\n    error TickSpacingTooSmall();\\n\\n    /// @notice PoolKey must have currencies where address(currency0) < address(currency1)\\n    error CurrenciesInitializedOutOfOrder();\\n\\n    /// @notice Emitted when a new pool is initialized\\n    /// @param id The abi encoded hash of the pool key struct for the new pool\\n    /// @param currency0 The first currency of the pool by address sort order\\n    /// @param currency1 The second currency of the pool by address sort order\\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\\n    /// @param hooks The hooks contract address for the pool, or address(0) if none\\n    event Initialize(\\n        PoolId indexed id,\\n        Currency indexed currency0,\\n        Currency indexed currency1,\\n        uint24 fee,\\n        int24 tickSpacing,\\n        IHooks hooks\\n    );\\n\\n    /// @notice Emitted when a liquidity position is modified\\n    /// @param id The abi encoded hash of the pool key struct for the pool that was modified\\n    /// @param sender The address that modified the pool\\n    /// @param tickLower The lower tick of the position\\n    /// @param tickUpper The upper tick of the position\\n    /// @param liquidityDelta The amount of liquidity that was added or removed\\n    event ModifyPosition(\\n        PoolId indexed id, address indexed sender, int24 tickLower, int24 tickUpper, int256 liquidityDelta\\n    );\\n\\n    /// @notice Emitted for swaps between currency0 and currency1\\n    /// @param id The abi encoded hash of the pool key struct for the pool that was modified\\n    /// @param sender The address that initiated the swap call, and that received the callback\\n    /// @param amount0 The delta of the currency0 balance of the pool\\n    /// @param amount1 The delta of the currency1 balance of the pool\\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\\n    /// @param liquidity The liquidity of the pool after the swap\\n    /// @param tick The log base 1.0001 of the price of the pool after the swap\\n    event Swap(\\n        PoolId indexed id,\\n        address indexed sender,\\n        int128 amount0,\\n        int128 amount1,\\n        uint160 sqrtPriceX96,\\n        uint128 liquidity,\\n        int24 tick,\\n        uint24 fee\\n    );\\n\\n    event ProtocolFeeUpdated(PoolId indexed id, uint24 protocolFees);\\n\\n    event HookFeeUpdated(PoolId indexed id, uint24 hookFees);\\n\\n    /// @notice Returns the constant representing the maximum tickSpacing for an initialized pool key\\n    function MAX_TICK_SPACING() external view returns (int24);\\n\\n    /// @notice Returns the constant representing the minimum tickSpacing for an initialized pool key\\n    function MIN_TICK_SPACING() external view returns (int24);\\n\\n    /// @notice Get the current value in slot0 of the given pool\\n    function getSlot0(PoolId id)\\n        external\\n        view\\n        returns (uint160 sqrtPriceX96, int24 tick, uint24 protocolFees, uint24 hookFees);\\n\\n    /// @notice Get the current value of liquidity of the given pool\\n    function getLiquidity(PoolId id) external view returns (uint128 liquidity);\\n\\n    /// @notice Get the current value of liquidity for the specified pool and position\\n    function getLiquidity(PoolId id, address owner, int24 tickLower, int24 tickUpper)\\n        external\\n        view\\n        returns (uint128 liquidity);\\n\\n    /// @notice Get the position struct for a specified pool and position\\n    function getPosition(PoolId id, address owner, int24 tickLower, int24 tickUpper)\\n        external\\n        view\\n        returns (Position.Info memory position);\\n\\n    /// @notice Returns the reserves for a given ERC20 currency\\n    function reservesOf(Currency currency) external view returns (uint256);\\n\\n    /// @notice Contains data about pool lockers.\\n    struct LockData {\\n        /// @notice The current number of active lockers\\n        uint128 length;\\n        /// @notice The total number of nonzero deltas over all active + completed lockers\\n        uint128 nonzeroDeltaCount;\\n    }\\n\\n    /// @notice Returns the locker in the ith position of the locker queue.\\n    function getLock(uint256 i) external view returns (address locker);\\n\\n    /// @notice Returns lock data\\n    function lockData() external view returns (uint128 length, uint128 nonzeroDeltaCount);\\n\\n    /// @notice Initialize the state for a given pool ID\\n    function initialize(PoolKey memory key, uint160 sqrtPriceX96, bytes calldata hookData)\\n        external\\n        returns (int24 tick);\\n\\n    /// @notice Get the current delta for a locker in the given currency\\n    /// @param locker The address of the locker\\n    /// @param currency The currency for which to lookup the delta\\n    function currencyDelta(address locker, Currency currency) external view returns (int256);\\n\\n    /// @notice All operations go through this function\\n    /// @param data Any data to pass to the callback, via `ILockCallback(msg.sender).lockCallback(data)`\\n    /// @return The data returned by the call to `ILockCallback(msg.sender).lockCallback(data)`\\n    function lock(bytes calldata data) external returns (bytes memory);\\n\\n    struct ModifyPositionParams {\\n        // the lower and upper tick of the position\\n        int24 tickLower;\\n        int24 tickUpper;\\n        // how to modify the liquidity\\n        int256 liquidityDelta;\\n    }\\n\\n    /// @notice Modify the position for the given pool\\n    function modifyPosition(PoolKey memory key, ModifyPositionParams memory params, bytes calldata hookData)\\n        external\\n        returns (BalanceDelta);\\n\\n    struct SwapParams {\\n        bool zeroForOne;\\n        int256 amountSpecified;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swap against the given pool\\n    function swap(PoolKey memory key, SwapParams memory params, bytes calldata hookData)\\n        external\\n        returns (BalanceDelta);\\n\\n    /// @notice Donate the given currency amounts to the pool with the given pool key\\n    function donate(PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)\\n        external\\n        returns (BalanceDelta);\\n\\n    /// @notice Called by the user to net out some value owed to the user\\n    /// @dev Can also be used as a mechanism for _free_ flash loans\\n    function take(Currency currency, address to, uint256 amount) external;\\n\\n    /// @notice Called by the user to move value into ERC1155 balance\\n    function mint(Currency token, address to, uint256 amount) external;\\n\\n    /// @notice Called by the user to pay what is owed\\n    function settle(Currency token) external payable returns (uint256 paid);\\n\\n    /// @notice Sets the protocol's swap and withdrawal fees for the given pool\\n    /// Protocol fees are always a portion of a fee that is owed. If that underlying fee is 0, no protocol fees will accrue even if it is set to > 0.\\n    function setProtocolFees(PoolKey memory key) external;\\n\\n    /// @notice Sets the hook's swap and withdrawal fees for the given pool\\n    function setHookFees(PoolKey memory key) external;\\n\\n    /// @notice Called by external contracts to access granular pool state\\n    /// @param slot Key of slot to sload\\n    /// @return value The value of the slot as bytes32\\n    function extsload(bytes32 slot) external view returns (bytes32 value);\\n\\n    /// @notice Called by external contracts to access granular pool state\\n    /// @param slot Key of slot to start sloading from\\n    /// @param nSlots Number of slots to load into return value\\n    /// @return value The value of the sload-ed slots concatenated as dynamic bytes\\n    function extsload(bytes32 slot, uint256 nSlots) external view returns (bytes memory value);\\n}\\n\",\"keccak256\":\"0x3fbfd91bbfc633e40250fff6d7d16584ba0b1a0ad71c10b54dea65e2abea844a\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/interfaces/IProtocolFeeController.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {PoolKey} from \\\"../types/PoolKey.sol\\\";\\n\\ninterface IProtocolFeeController {\\n    /// @notice Returns the protocol fees for a pool given the conditions of this contract\\n    /// @param poolKey The pool key to identify the pool. The controller may want to use attributes on the pool\\n    ///   to determine the protocol fee, hence the entire key is needed.\\n    function protocolFeesForPool(PoolKey memory poolKey) external view returns (uint24);\\n}\\n\",\"keccak256\":\"0x8cfe1e67530ab254d9f0333d391d5f80719921902e5a1f1d6d1f93eb76642953\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/interfaces/callback/ILockCallback.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\ninterface ILockCallback {\\n    /// @notice Called by the pool manager on `msg.sender` when a lock is acquired\\n    /// @param data The data that was passed to the call to lock\\n    /// @return Any data that you want to be returned from the lock call\\n    function lockAcquired(bytes calldata data) external returns (bytes memory);\\n}\\n\",\"keccak256\":\"0xbbe48da53b400e2ebe65e8b2d7fff212f4da3657bafec984c9144387c98f1816\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/interfaces/external/IERC20Minimal.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\n/// @title Minimal ERC20 interface for Uniswap\\n/// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3\\ninterface IERC20Minimal {\\n    /// @notice Returns the balance of a token\\n    /// @param account The account for which to look up the number of tokens it has, i.e. its balance\\n    /// @return The number of tokens held by the account\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /// @notice Transfers the amount of token from the `msg.sender` to the recipient\\n    /// @param recipient The account that will receive the amount transferred\\n    /// @param amount The number of tokens to send from the sender to the recipient\\n    /// @return Returns true for a successful transfer, false for an unsuccessful transfer\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /// @notice Returns the current allowance given to a spender by an owner\\n    /// @param owner The account of the token owner\\n    /// @param spender The account of the token spender\\n    /// @return The current allowance granted by `owner` to `spender`\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`\\n    /// @param spender The account which will be allowed to spend a given amount of the owners tokens\\n    /// @param amount The amount of tokens allowed to be used by `spender`\\n    /// @return Returns true for a successful approval, false for unsuccessful\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`\\n    /// @param sender The account from which the transfer will be initiated\\n    /// @param recipient The recipient of the transfer\\n    /// @param amount The amount of the transfer\\n    /// @return Returns true for a successful transfer, false for unsuccessful\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.\\n    /// @param from The account from which the tokens were sent, i.e. the balance decreased\\n    /// @param to The account to which the tokens were sent, i.e. the balance increased\\n    /// @param value The amount of tokens that were transferred\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.\\n    /// @param owner The account that approved spending of its tokens\\n    /// @param spender The account for which the spending allowance was modified\\n    /// @param value The new allowance from the owner to the spender\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x8dc5ee72426906aeb12f4ae6a2426df059491739bd5cbdb8ea4a3e26970436c6\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/libraries/BitMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\n/// @title BitMath\\n/// @dev This library provides functionality for computing bit properties of an unsigned integer\\nlibrary BitMath {\\n    /// @notice Returns the index of the most significant bit of the number,\\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\\n    /// @dev The function satisfies the property:\\n    ///     x >= 2**mostSignificantBit(x) and x < 2**(mostSignificantBit(x)+1)\\n    /// @param x the value for which to compute the most significant bit, must be greater than 0\\n    /// @return r the index of the most significant bit\\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\\n        require(x > 0);\\n\\n        unchecked {\\n            if (x >= 0x100000000000000000000000000000000) {\\n                x >>= 128;\\n                r += 128;\\n            }\\n            if (x >= 0x10000000000000000) {\\n                x >>= 64;\\n                r += 64;\\n            }\\n            if (x >= 0x100000000) {\\n                x >>= 32;\\n                r += 32;\\n            }\\n            if (x >= 0x10000) {\\n                x >>= 16;\\n                r += 16;\\n            }\\n            if (x >= 0x100) {\\n                x >>= 8;\\n                r += 8;\\n            }\\n            if (x >= 0x10) {\\n                x >>= 4;\\n                r += 4;\\n            }\\n            if (x >= 0x4) {\\n                x >>= 2;\\n                r += 2;\\n            }\\n            if (x >= 0x2) r += 1;\\n        }\\n    }\\n\\n    /// @notice Returns the index of the least significant bit of the number,\\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\\n    /// @dev The function satisfies the property:\\n    ///     (x & 2**leastSignificantBit(x)) != 0 and (x & (2**(leastSignificantBit(x)) - 1)) == 0)\\n    /// @param x the value for which to compute the least significant bit, must be greater than 0\\n    /// @return r the index of the least significant bit\\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\\n        require(x > 0);\\n\\n        unchecked {\\n            r = 255;\\n            if (x & type(uint128).max > 0) {\\n                r -= 128;\\n            } else {\\n                x >>= 128;\\n            }\\n            if (x & type(uint64).max > 0) {\\n                r -= 64;\\n            } else {\\n                x >>= 64;\\n            }\\n            if (x & type(uint32).max > 0) {\\n                r -= 32;\\n            } else {\\n                x >>= 32;\\n            }\\n            if (x & type(uint16).max > 0) {\\n                r -= 16;\\n            } else {\\n                x >>= 16;\\n            }\\n            if (x & type(uint8).max > 0) {\\n                r -= 8;\\n            } else {\\n                x >>= 8;\\n            }\\n            if (x & 0xf > 0) {\\n                r -= 4;\\n            } else {\\n                x >>= 4;\\n            }\\n            if (x & 0x3 > 0) {\\n                r -= 2;\\n            } else {\\n                x >>= 2;\\n            }\\n            if (x & 0x1 > 0) r -= 1;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x652cd36970d953b3067c766b3b0c0063d4c403eba7352df09ec10dcc868910d9\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/libraries/FeeLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\nlibrary FeeLibrary {\\n    uint24 public constant STATIC_FEE_MASK = 0x0FFFFF;\\n    uint24 public constant DYNAMIC_FEE_FLAG = 0x800000; // 1000\\n    uint24 public constant HOOK_SWAP_FEE_FLAG = 0x400000; // 0100\\n    uint24 public constant HOOK_WITHDRAW_FEE_FLAG = 0x200000; // 0010\\n\\n    function isDynamicFee(uint24 self) internal pure returns (bool) {\\n        return self & DYNAMIC_FEE_FLAG != 0;\\n    }\\n\\n    function hasHookSwapFee(uint24 self) internal pure returns (bool) {\\n        return self & HOOK_SWAP_FEE_FLAG != 0;\\n    }\\n\\n    function hasHookWithdrawFee(uint24 self) internal pure returns (bool) {\\n        return self & HOOK_WITHDRAW_FEE_FLAG != 0;\\n    }\\n\\n    function isStaticFeeTooLarge(uint24 self) internal pure returns (bool) {\\n        return self & STATIC_FEE_MASK >= 1000000;\\n    }\\n\\n    function getStaticFee(uint24 self) internal pure returns (uint24) {\\n        return self & STATIC_FEE_MASK;\\n    }\\n}\\n\",\"keccak256\":\"0x9fc00b77978b617d1a9b5c9d024210b43ee5455682982703d3009bfafc1c12b4\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/libraries/FixedPoint128.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\n/// @title FixedPoint128\\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\\nlibrary FixedPoint128 {\\n    uint256 internal constant Q128 = 0x100000000000000000000000000000000;\\n}\\n\",\"keccak256\":\"0x1f015a7a107f4c471985a958f1bfbc1710948f9bcd3786a02310bc0ad5080c69\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/libraries/FixedPoint96.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\n/// @title FixedPoint96\\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\\n/// @dev Used in SqrtPriceMath.sol\\nlibrary FixedPoint96 {\\n    uint8 internal constant RESOLUTION = 96;\\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\\n}\\n\",\"keccak256\":\"0x7731aeeba692b0ca5dac8f27803ec9e5ce98795a554c09ae05c220861bd0314e\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/libraries/FullMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = a * b\\n            // Compute the product mod 2**256 and mod 2**256 - 1\\n            // then use the Chinese Remainder Theorem to reconstruct\\n            // the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2**256 + prod0\\n            uint256 prod0 = a * b; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(a, b, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Make sure the result is less than 2**256.\\n            // Also prevents denominator == 0\\n            require(denominator > prod1);\\n\\n            // Handle non-overflow cases, 256 by 256 division\\n            if (prod1 == 0) {\\n                assembly {\\n                    result := div(prod0, denominator)\\n                }\\n                return result;\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0]\\n            // Compute remainder using mulmod\\n            uint256 remainder;\\n            assembly {\\n                remainder := mulmod(a, b, denominator)\\n            }\\n            // Subtract 256 bit number from 512 bit number\\n            assembly {\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator\\n            // Compute largest power of two divisor of denominator.\\n            // Always >= 1.\\n            uint256 twos = (0 - denominator) & denominator;\\n            // Divide denominator by power of two\\n            assembly {\\n                denominator := div(denominator, twos)\\n            }\\n\\n            // Divide [prod1 prod0] by the factors of two\\n            assembly {\\n                prod0 := div(prod0, twos)\\n            }\\n            // Shift in bits from prod1 into prod0. For this we need\\n            // to flip `twos` such that it is 2**256 / twos.\\n            // If twos is zero, then it becomes one\\n            assembly {\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2**256\\n            // Now that denominator is an odd number, it has an inverse\\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n            // Compute the inverse by starting with a seed that is correct\\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n            uint256 inv = (3 * denominator) ^ 2;\\n            // Now use Newton-Raphson iteration to improve the precision.\\n            // Thanks to Hensel's lifting lemma, this also works in modular\\n            // arithmetic, doubling the correct bits in each step.\\n            inv *= 2 - denominator * inv; // inverse mod 2**8\\n            inv *= 2 - denominator * inv; // inverse mod 2**16\\n            inv *= 2 - denominator * inv; // inverse mod 2**32\\n            inv *= 2 - denominator * inv; // inverse mod 2**64\\n            inv *= 2 - denominator * inv; // inverse mod 2**128\\n            inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n            // Because the division is now exact we can divide by multiplying\\n            // with the modular inverse of denominator. This will give us the\\n            // correct result modulo 2**256. Since the preconditions guarantee\\n            // that the outcome is less than 2**256, this is the final result.\\n            // We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inv;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates ceil(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            result = mulDiv(a, b, denominator);\\n            if (mulmod(a, b, denominator) > 0) {\\n                require(result < type(uint256).max);\\n                result++;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6d8760794ed38264579c5da7b2afe8ff5543de999180850bc08687b77dce36ea\",\"license\":\"MIT\"},\"@uniswap/v4-core/contracts/libraries/Hooks.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.20;\\n\\nimport {IHooks} from \\\"../interfaces/IHooks.sol\\\";\\nimport {FeeLibrary} from \\\"../libraries/FeeLibrary.sol\\\";\\n\\n/// @notice V4 decides whether to invoke specific hooks by inspecting the leading bits of the address that\\n/// the hooks contract is deployed to.\\n/// For example, a hooks contract deployed to address: 0x9000000000000000000000000000000000000000\\n/// has leading bits '1001' which would cause the 'before initialize' and 'after modify position' hooks to be used.\\nlibrary Hooks {\\n    using FeeLibrary for uint24;\\n\\n    uint256 internal constant BEFORE_INITIALIZE_FLAG = 1 << 159;\\n    uint256 internal constant AFTER_INITIALIZE_FLAG = 1 << 158;\\n    uint256 internal constant BEFORE_MODIFY_POSITION_FLAG = 1 << 157;\\n    uint256 internal constant AFTER_MODIFY_POSITION_FLAG = 1 << 156;\\n    uint256 internal constant BEFORE_SWAP_FLAG = 1 << 155;\\n    uint256 internal constant AFTER_SWAP_FLAG = 1 << 154;\\n    uint256 internal constant BEFORE_DONATE_FLAG = 1 << 153;\\n    uint256 internal constant AFTER_DONATE_FLAG = 1 << 152;\\n\\n    struct Calls {\\n        bool beforeInitialize;\\n        bool afterInitialize;\\n        bool beforeModifyPosition;\\n        bool afterModifyPosition;\\n        bool beforeSwap;\\n        bool afterSwap;\\n        bool beforeDonate;\\n        bool afterDonate;\\n    }\\n\\n    /// @notice Thrown if the address will not lead to the specified hook calls being called\\n    /// @param hooks The address of the hooks contract\\n    error HookAddressNotValid(address hooks);\\n\\n    /// @notice Hook did not return its selector\\n    error InvalidHookResponse();\\n\\n    /// @notice Utility function intended to be used in hook constructors to ensure\\n    /// the deployed hooks address causes the intended hooks to be called\\n    /// @param calls The hooks that are intended to be called\\n    /// @dev calls param is memory as the function will be called from constructors\\n    function validateHookAddress(IHooks self, Calls memory calls) internal pure {\\n        if (\\n            calls.beforeInitialize != shouldCallBeforeInitialize(self)\\n                || calls.afterInitialize != shouldCallAfterInitialize(self)\\n                || calls.beforeModifyPosition != shouldCallBeforeModifyPosition(self)\\n                || calls.afterModifyPosition != shouldCallAfterModifyPosition(self)\\n                || calls.beforeSwap != shouldCallBeforeSwap(self) || calls.afterSwap != shouldCallAfterSwap(self)\\n                || calls.beforeDonate != shouldCallBeforeDonate(self) || calls.afterDonate != shouldCallAfterDonate(self)\\n        ) {\\n            revert HookAddressNotValid(address(self));\\n        }\\n    }\\n\\n    /// @notice Ensures that the hook address includes at least one hook flag or dynamic fees, or is the 0 address\\n    /// @param hook The hook to verify\\n    function isValidHookAddress(IHooks hook, uint24 fee) internal pure returns (bool) {\\n        // If there is no hook contract set, then fee cannot be dynamic and there cannot be a hook fee on swap or withdrawal.\\n        return address(hook) == address(0)\\n            ? !fee.isDynamicFee() && !fee.hasHookSwapFee() && !fee.hasHookWithdrawFee()\\n            : (\\n                uint160(address(hook)) >= AFTER_DONATE_FLAG || fee.isDynamicFee() || fee.hasHookSwapFee()\\n                    || fee.hasHookWithdrawFee()\\n            );\\n    }\\n\\n    function shouldCallBeforeInitialize(IHooks self) internal pure returns (bool) {\\n        return uint256(uint160(address(self))) & BEFORE_INITIALIZE_FLAG != 0;\\n    }\\n\\n    function shouldCallAfterInitialize(IHooks self) internal pure returns (bool) {\\n        return uint256(uint160(address(self))) & AFTER_INITIALIZE_FLAG != 0;\\n    }\\n\\n    function shouldCallBeforeModifyPosition(IHooks self) internal pure returns (bool) {\\n        return uint256(uint160(address(self))) & BEFORE_MODIFY_POSITION_FLAG != 0;\\n    }\\n\\n    function shouldCallAfterModifyPosition(IHooks self) internal pure returns (bool) {\\n        return uint256(uint160(address(self))) & AFTER_MODIFY_POSITION_FLAG != 0;\\n    }\\n\\n    function shouldCallBeforeSwap(IHooks self) internal pure returns (bool) {\\n        return uint256(uint160(address(self))) & BEFORE_SWAP_FLAG != 0;\\n    }\\n\\n    function shouldCallAfterSwap(IHooks self) internal pure returns (bool) {\\n        return uint256(uint160(address(self))) & AFTER_SWAP_FLAG != 0;\\n    }\\n\\n    function shouldCallBeforeDonate(IHooks self) internal pure returns (bool) {\\n        return uint256(uint160(address(self))) & BEFORE_DONATE_FLAG != 0;\\n    }\\n\\n    function shouldCallAfterDonate(IHooks self) internal pure returns (bool) {\\n        return uint256(uint160(address(self))) & AFTER_DONATE_FLAG != 0;\\n    }\\n}\\n\",\"keccak256\":\"0x5015985a12cecb006731861d738d79d489991ef64cddf648d5c4224c775bf28e\",\"license\":\"BUSL-1.1\"},\"@uniswap/v4-core/contracts/libraries/LockDataLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.20;\\n\\nimport {IPoolManager} from \\\"../interfaces/IPoolManager.sol\\\";\\n\\n/// @dev This library manages a custom storage implementation for a queue\\n///      that tracks current lockers. The \\\"sentinel\\\" storage slot for this data structure,\\n///      always passed in as IPoolManager.LockData storage self, stores not just the current\\n///      length of the queue but also the global count of non-zero deltas across all lockers.\\n///      The values of the data structure start at OFFSET, and each value is a locker address.\\nlibrary LockDataLibrary {\\n    uint256 private constant OFFSET = uint256(keccak256(\\\"LockData\\\"));\\n\\n    /// @dev Pushes a locker onto the end of the queue, and updates the sentinel storage slot.\\n    function push(IPoolManager.LockData storage self, address locker) internal {\\n        // read current value from the sentinel storage slot\\n        uint128 length = self.length;\\n        unchecked {\\n            uint256 indexToWrite = OFFSET + length; // not in assembly because OFFSET is in the library scope\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // in the next storage slot, write the locker\\n                sstore(indexToWrite, locker)\\n            }\\n            // update the sentinel storage slot\\n            self.length = length + 1;\\n        }\\n    }\\n\\n    /// @dev Pops a locker off the end of the queue. Note that no storage gets cleared.\\n    function pop(IPoolManager.LockData storage self) internal {\\n        unchecked {\\n            self.length--;\\n        }\\n    }\\n\\n    function getLock(uint256 i) internal view returns (address locker) {\\n        unchecked {\\n            uint256 position = OFFSET + i; // not in assembly because OFFSET is in the library scope\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                locker := sload(position)\\n            }\\n        }\\n    }\\n\\n    function getActiveLock(IPoolManager.LockData storage self) internal view returns (address locker) {\\n        return getLock(self.length - 1);\\n    }\\n}\\n\",\"keccak256\":\"0xf4be97b50bca4e569e0e2c8555b11e7397bf79c04fc0322c9d74a9a87fa31674\",\"license\":\"BUSL-1.1\"},\"@uniswap/v4-core/contracts/libraries/Pool.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.20;\\n\\nimport {SafeCast} from \\\"./SafeCast.sol\\\";\\nimport {TickBitmap} from \\\"./TickBitmap.sol\\\";\\nimport {Position} from \\\"./Position.sol\\\";\\nimport {FullMath} from \\\"./FullMath.sol\\\";\\nimport {FixedPoint128} from \\\"./FixedPoint128.sol\\\";\\nimport {TickMath} from \\\"./TickMath.sol\\\";\\nimport {SqrtPriceMath} from \\\"./SqrtPriceMath.sol\\\";\\nimport {SwapMath} from \\\"./SwapMath.sol\\\";\\nimport {BalanceDelta, toBalanceDelta} from \\\"../types/BalanceDelta.sol\\\";\\n\\nlibrary Pool {\\n    using SafeCast for *;\\n    using TickBitmap for mapping(int16 => uint256);\\n    using Position for mapping(bytes32 => Position.Info);\\n    using Position for Position.Info;\\n\\n    /// @notice Thrown when tickLower is not below tickUpper\\n    /// @param tickLower The invalid tickLower\\n    /// @param tickUpper The invalid tickUpper\\n    error TicksMisordered(int24 tickLower, int24 tickUpper);\\n\\n    /// @notice Thrown when tickLower is less than min tick\\n    /// @param tickLower The invalid tickLower\\n    error TickLowerOutOfBounds(int24 tickLower);\\n\\n    /// @notice Thrown when tickUpper exceeds max tick\\n    /// @param tickUpper The invalid tickUpper\\n    error TickUpperOutOfBounds(int24 tickUpper);\\n\\n    /// @notice For the tick spacing, the tick has too much liquidity\\n    error TickLiquidityOverflow(int24 tick);\\n\\n    /// @notice Thrown when interacting with an uninitialized tick that must be initialized\\n    /// @param tick The uninitialized tick\\n    error TickNotInitialized(int24 tick);\\n\\n    /// @notice Thrown when trying to initalize an already initialized pool\\n    error PoolAlreadyInitialized();\\n\\n    /// @notice Thrown when trying to interact with a non-initialized pool\\n    error PoolNotInitialized();\\n\\n    /// @notice Thrown when trying to swap amount of 0\\n    error SwapAmountCannotBeZero();\\n\\n    /// @notice Thrown when sqrtPriceLimitX96 on a swap has already exceeded its limit\\n    /// @param sqrtPriceCurrentX96 The invalid, already surpassed sqrtPriceLimitX96\\n    /// @param sqrtPriceLimitX96 The surpassed price limit\\n    error PriceLimitAlreadyExceeded(uint160 sqrtPriceCurrentX96, uint160 sqrtPriceLimitX96);\\n\\n    /// @notice Thrown when sqrtPriceLimitX96 lies outside of valid tick/price range\\n    /// @param sqrtPriceLimitX96 The invalid, out-of-bounds sqrtPriceLimitX96\\n    error PriceLimitOutOfBounds(uint160 sqrtPriceLimitX96);\\n\\n    /// @notice Thrown by donate if there is currently 0 liquidity, since the fees will not go to any liquidity providers\\n    error NoLiquidityToReceiveFees();\\n\\n    /// Each uint24 variable packs both the swap fees and the withdraw fees represented as integer denominators (1/x). The upper 12 bits are the swap fees, and the lower 12 bits\\n    /// are the withdraw fees. For swap fees, the upper 6 bits are the fee for trading 1 for 0, and the lower 6 are for 0 for 1 and are taken as a percentage of the lp swap fee.\\n    /// For withdraw fees the upper 6 bits are the fee on amount1, and the lower 6 are for amount0 and are taken as a percentage of the principle amount of the underlying position.\\n    /// bits          24 22 20 18 16 14 12 10 8  6  4  2  0\\n    ///               |    swapFees     |   withdrawFees  |\\n    ///               \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510\\n    /// protocolFees: | 1->0   |  0->1  |  fee1  |  fee0  |\\n    /// hookFees:     | 1->0   |  0->1  |  fee1  |  fee0  |\\n    ///               \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518\\n    struct Slot0 {\\n        // the current price\\n        uint160 sqrtPriceX96;\\n        // the current tick\\n        int24 tick;\\n        uint24 protocolFees;\\n        uint24 hookFees;\\n    }\\n    // 24 bits left!\\n\\n    // info stored for each initialized individual tick\\n    struct TickInfo {\\n        // the total position liquidity that references this tick\\n        uint128 liquidityGross;\\n        // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),\\n        int128 liquidityNet;\\n        // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\\n        // only has relative meaning, not absolute \\u2014 the value depends on when the tick is initialized\\n        uint256 feeGrowthOutside0X128;\\n        uint256 feeGrowthOutside1X128;\\n    }\\n\\n    /// @dev The state of a pool\\n    struct State {\\n        Slot0 slot0;\\n        uint256 feeGrowthGlobal0X128;\\n        uint256 feeGrowthGlobal1X128;\\n        uint128 liquidity;\\n        mapping(int24 => TickInfo) ticks;\\n        mapping(int16 => uint256) tickBitmap;\\n        mapping(bytes32 => Position.Info) positions;\\n    }\\n\\n    /// @dev Common checks for valid tick inputs.\\n    function checkTicks(int24 tickLower, int24 tickUpper) private pure {\\n        if (tickLower >= tickUpper) revert TicksMisordered(tickLower, tickUpper);\\n        if (tickLower < TickMath.MIN_TICK) revert TickLowerOutOfBounds(tickLower);\\n        if (tickUpper > TickMath.MAX_TICK) revert TickUpperOutOfBounds(tickUpper);\\n    }\\n\\n    function initialize(State storage self, uint160 sqrtPriceX96, uint24 protocolFees, uint24 hookFees)\\n        internal\\n        returns (int24 tick)\\n    {\\n        if (self.slot0.sqrtPriceX96 != 0) revert PoolAlreadyInitialized();\\n\\n        tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);\\n\\n        self.slot0 = Slot0({sqrtPriceX96: sqrtPriceX96, tick: tick, protocolFees: protocolFees, hookFees: hookFees});\\n    }\\n\\n    function getSwapFee(uint24 feesStorage) internal pure returns (uint16) {\\n        return uint16(feesStorage >> 12);\\n    }\\n\\n    function getWithdrawFee(uint24 feesStorage) internal pure returns (uint16) {\\n        return uint16(feesStorage & 0xFFF);\\n    }\\n\\n    function setProtocolFees(State storage self, uint24 protocolFees) internal {\\n        if (self.slot0.sqrtPriceX96 == 0) revert PoolNotInitialized();\\n\\n        self.slot0.protocolFees = protocolFees;\\n    }\\n\\n    function setHookFees(State storage self, uint24 hookFees) internal {\\n        if (self.slot0.sqrtPriceX96 == 0) revert PoolNotInitialized();\\n\\n        self.slot0.hookFees = hookFees;\\n    }\\n\\n    struct ModifyPositionParams {\\n        // the address that owns the position\\n        address owner;\\n        // the lower and upper tick of the position\\n        int24 tickLower;\\n        int24 tickUpper;\\n        // any change in liquidity\\n        int128 liquidityDelta;\\n        // the spacing between ticks\\n        int24 tickSpacing;\\n    }\\n\\n    struct ModifyPositionState {\\n        bool flippedLower;\\n        uint128 liquidityGrossAfterLower;\\n        bool flippedUpper;\\n        uint128 liquidityGrossAfterUpper;\\n        uint256 feeGrowthInside0X128;\\n        uint256 feeGrowthInside1X128;\\n    }\\n\\n    struct FeeAmounts {\\n        uint256 feeForProtocol0;\\n        uint256 feeForProtocol1;\\n        uint256 feeForHook0;\\n        uint256 feeForHook1;\\n    }\\n\\n    /// @dev Effect changes to a position in a pool\\n    /// @param params the position details and the change to the position's liquidity to effect\\n    /// @return result the deltas of the token balances of the pool\\n    function modifyPosition(State storage self, ModifyPositionParams memory params)\\n        internal\\n        returns (BalanceDelta result, FeeAmounts memory fees)\\n    {\\n        if (self.slot0.sqrtPriceX96 == 0) revert PoolNotInitialized();\\n\\n        checkTicks(params.tickLower, params.tickUpper);\\n\\n        uint256 feesOwed0;\\n        uint256 feesOwed1;\\n        {\\n            ModifyPositionState memory state;\\n            // if we need to update the ticks, do it\\n\\n            if (params.liquidityDelta != 0) {\\n                (state.flippedLower, state.liquidityGrossAfterLower) =\\n                    updateTick(self, params.tickLower, params.liquidityDelta, false);\\n                (state.flippedUpper, state.liquidityGrossAfterUpper) =\\n                    updateTick(self, params.tickUpper, params.liquidityDelta, true);\\n\\n                if (params.liquidityDelta > 0) {\\n                    uint128 maxLiquidityPerTick = tickSpacingToMaxLiquidityPerTick(params.tickSpacing);\\n                    if (state.liquidityGrossAfterLower > maxLiquidityPerTick) {\\n                        revert TickLiquidityOverflow(params.tickLower);\\n                    }\\n                    if (state.liquidityGrossAfterUpper > maxLiquidityPerTick) {\\n                        revert TickLiquidityOverflow(params.tickUpper);\\n                    }\\n                }\\n\\n                if (state.flippedLower) {\\n                    self.tickBitmap.flipTick(params.tickLower, params.tickSpacing);\\n                }\\n                if (state.flippedUpper) {\\n                    self.tickBitmap.flipTick(params.tickUpper, params.tickSpacing);\\n                }\\n            }\\n\\n            (state.feeGrowthInside0X128, state.feeGrowthInside1X128) =\\n                getFeeGrowthInside(self, params.tickLower, params.tickUpper);\\n\\n            (feesOwed0, feesOwed1) = self.positions.get(params.owner, params.tickLower, params.tickUpper).update(\\n                params.liquidityDelta, state.feeGrowthInside0X128, state.feeGrowthInside1X128\\n            );\\n\\n            // clear any tick data that is no longer needed\\n            if (params.liquidityDelta < 0) {\\n                if (state.flippedLower) {\\n                    clearTick(self, params.tickLower);\\n                }\\n                if (state.flippedUpper) {\\n                    clearTick(self, params.tickUpper);\\n                }\\n            }\\n        }\\n\\n        if (params.liquidityDelta != 0) {\\n            if (self.slot0.tick < params.tickLower) {\\n                // current tick is below the passed range; liquidity can only become in range by crossing from left to\\n                // right, when we'll need _more_ currency0 (it's becoming more valuable) so user must provide it\\n                result = result\\n                    + toBalanceDelta(\\n                        SqrtPriceMath.getAmount0Delta(\\n                            TickMath.getSqrtRatioAtTick(params.tickLower),\\n                            TickMath.getSqrtRatioAtTick(params.tickUpper),\\n                            params.liquidityDelta\\n                        ).toInt128(),\\n                        0\\n                    );\\n            } else if (self.slot0.tick < params.tickUpper) {\\n                result = result\\n                    + toBalanceDelta(\\n                        SqrtPriceMath.getAmount0Delta(\\n                            self.slot0.sqrtPriceX96, TickMath.getSqrtRatioAtTick(params.tickUpper), params.liquidityDelta\\n                        ).toInt128(),\\n                        SqrtPriceMath.getAmount1Delta(\\n                            TickMath.getSqrtRatioAtTick(params.tickLower), self.slot0.sqrtPriceX96, params.liquidityDelta\\n                        ).toInt128()\\n                    );\\n\\n                self.liquidity = params.liquidityDelta < 0\\n                    ? self.liquidity - uint128(-params.liquidityDelta)\\n                    : self.liquidity + uint128(params.liquidityDelta);\\n            } else {\\n                // current tick is above the passed range; liquidity can only become in range by crossing from right to\\n                // left, when we'll need _more_ currency1 (it's becoming more valuable) so user must provide it\\n                result = result\\n                    + toBalanceDelta(\\n                        0,\\n                        SqrtPriceMath.getAmount1Delta(\\n                            TickMath.getSqrtRatioAtTick(params.tickLower),\\n                            TickMath.getSqrtRatioAtTick(params.tickUpper),\\n                            params.liquidityDelta\\n                        ).toInt128()\\n                    );\\n            }\\n        }\\n\\n        if (params.liquidityDelta < 0 && getWithdrawFee(self.slot0.hookFees) > 0) {\\n            // Only take fees if the hook withdraw fee is set and the liquidity is being removed.\\n            fees = _calculateExternalFees(self, result);\\n\\n            // Amounts are balances owed to the pool. When negative, they represent the balance a user can take.\\n            // Since protocol and hook fees are extracted on the balance a user can take\\n            // they are owed (added) back to the pool where they are kept to be collected by the fee recipients.\\n            result = result\\n                + toBalanceDelta(\\n                    fees.feeForHook0.toInt128() + fees.feeForProtocol0.toInt128(),\\n                    fees.feeForHook1.toInt128() + fees.feeForProtocol1.toInt128()\\n                );\\n        }\\n\\n        // Fees earned from LPing are removed from the pool balance.\\n        result = result - toBalanceDelta(feesOwed0.toInt128(), feesOwed1.toInt128());\\n    }\\n\\n    function _calculateExternalFees(State storage self, BalanceDelta result)\\n        internal\\n        view\\n        returns (FeeAmounts memory fees)\\n    {\\n        int128 amount0 = result.amount0();\\n        int128 amount1 = result.amount1();\\n\\n        Slot0 memory slot0Cache = self.slot0;\\n        uint24 hookFees = slot0Cache.hookFees;\\n        uint24 protocolFees = slot0Cache.protocolFees;\\n\\n        uint16 hookFee0 = getWithdrawFee(hookFees) % 64;\\n        uint16 hookFee1 = getWithdrawFee(hookFees) >> 6;\\n\\n        uint16 protocolFee0 = getWithdrawFee(protocolFees) % 64;\\n        uint16 protocolFee1 = getWithdrawFee(protocolFees) >> 6;\\n\\n        if (amount0 < 0 && hookFee0 > 0) {\\n            fees.feeForHook0 = uint128(-amount0) / hookFee0;\\n        }\\n        if (amount1 < 0 && hookFee1 > 0) {\\n            fees.feeForHook1 = uint128(-amount1) / hookFee1;\\n        }\\n\\n        // A protocol fee is only applied if the hook fee is applied.\\n        if (protocolFee0 > 0 && fees.feeForHook0 > 0) {\\n            fees.feeForProtocol0 = fees.feeForHook0 / protocolFee0;\\n            fees.feeForHook0 -= fees.feeForProtocol0;\\n        }\\n\\n        if (protocolFee1 > 0 && fees.feeForHook1 > 0) {\\n            fees.feeForProtocol1 = fees.feeForHook1 / protocolFee1;\\n            fees.feeForHook1 -= fees.feeForProtocol1;\\n        }\\n\\n        return fees;\\n    }\\n\\n    struct SwapCache {\\n        // liquidity at the beginning of the swap\\n        uint128 liquidityStart;\\n        // the protocol fee for the input token\\n        uint16 protocolFee;\\n        // the hook fee for the input token\\n        uint16 hookFee;\\n    }\\n\\n    // the top level state of the swap, the results of which are recorded in storage at the end\\n    struct SwapState {\\n        // the amount remaining to be swapped in/out of the input/output asset\\n        int256 amountSpecifiedRemaining;\\n        // the amount already swapped out/in of the output/input asset\\n        int256 amountCalculated;\\n        // current sqrt(price)\\n        uint160 sqrtPriceX96;\\n        // the tick associated with the current price\\n        int24 tick;\\n        // the global fee growth of the input token\\n        uint256 feeGrowthGlobalX128;\\n        // the current liquidity in range\\n        uint128 liquidity;\\n    }\\n\\n    struct StepComputations {\\n        // the price at the beginning of the step\\n        uint160 sqrtPriceStartX96;\\n        // the next tick to swap to from the current tick in the swap direction\\n        int24 tickNext;\\n        // whether tickNext is initialized or not\\n        bool initialized;\\n        // sqrt(price) for the next tick (1/0)\\n        uint160 sqrtPriceNextX96;\\n        // how much is being swapped in in this step\\n        uint256 amountIn;\\n        // how much is being swapped out\\n        uint256 amountOut;\\n        // how much fee is being paid in\\n        uint256 feeAmount;\\n    }\\n\\n    struct SwapParams {\\n        uint24 fee;\\n        int24 tickSpacing;\\n        bool zeroForOne;\\n        int256 amountSpecified;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @dev Executes a swap against the state, and returns the amount deltas of the pool\\n    function swap(State storage self, SwapParams memory params)\\n        internal\\n        returns (BalanceDelta result, uint256 feeForProtocol, uint256 feeForHook, SwapState memory state)\\n    {\\n        if (params.amountSpecified == 0) revert SwapAmountCannotBeZero();\\n\\n        Slot0 memory slot0Start = self.slot0;\\n        if (slot0Start.sqrtPriceX96 == 0) revert PoolNotInitialized();\\n        if (params.zeroForOne) {\\n            if (params.sqrtPriceLimitX96 >= slot0Start.sqrtPriceX96) {\\n                revert PriceLimitAlreadyExceeded(slot0Start.sqrtPriceX96, params.sqrtPriceLimitX96);\\n            }\\n            if (params.sqrtPriceLimitX96 <= TickMath.MIN_SQRT_RATIO) {\\n                revert PriceLimitOutOfBounds(params.sqrtPriceLimitX96);\\n            }\\n        } else {\\n            if (params.sqrtPriceLimitX96 <= slot0Start.sqrtPriceX96) {\\n                revert PriceLimitAlreadyExceeded(slot0Start.sqrtPriceX96, params.sqrtPriceLimitX96);\\n            }\\n            if (params.sqrtPriceLimitX96 >= TickMath.MAX_SQRT_RATIO) {\\n                revert PriceLimitOutOfBounds(params.sqrtPriceLimitX96);\\n            }\\n        }\\n\\n        SwapCache memory cache = SwapCache({\\n            liquidityStart: self.liquidity,\\n            protocolFee: params.zeroForOne\\n                ? (getSwapFee(slot0Start.protocolFees) % 64)\\n                : (getSwapFee(slot0Start.protocolFees) >> 6),\\n            hookFee: params.zeroForOne ? (getSwapFee(slot0Start.hookFees) % 64) : (getSwapFee(slot0Start.hookFees) >> 6)\\n        });\\n\\n        bool exactInput = params.amountSpecified > 0;\\n\\n        state = SwapState({\\n            amountSpecifiedRemaining: params.amountSpecified,\\n            amountCalculated: 0,\\n            sqrtPriceX96: slot0Start.sqrtPriceX96,\\n            tick: slot0Start.tick,\\n            feeGrowthGlobalX128: params.zeroForOne ? self.feeGrowthGlobal0X128 : self.feeGrowthGlobal1X128,\\n            liquidity: cache.liquidityStart\\n        });\\n\\n        StepComputations memory step;\\n        // continue swapping as long as we haven't used the entire input/output and haven't reached the price limit\\n        while (state.amountSpecifiedRemaining != 0 && state.sqrtPriceX96 != params.sqrtPriceLimitX96) {\\n            step.sqrtPriceStartX96 = state.sqrtPriceX96;\\n\\n            (step.tickNext, step.initialized) =\\n                self.tickBitmap.nextInitializedTickWithinOneWord(state.tick, params.tickSpacing, params.zeroForOne);\\n\\n            // ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds\\n            if (step.tickNext < TickMath.MIN_TICK) {\\n                step.tickNext = TickMath.MIN_TICK;\\n            } else if (step.tickNext > TickMath.MAX_TICK) {\\n                step.tickNext = TickMath.MAX_TICK;\\n            }\\n\\n            // get the price for the next tick\\n            step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);\\n\\n            // compute values to swap to the target tick, price limit, or point where input/output amount is exhausted\\n            (state.sqrtPriceX96, step.amountIn, step.amountOut, step.feeAmount) = SwapMath.computeSwapStep(\\n                state.sqrtPriceX96,\\n                (\\n                    params.zeroForOne\\n                        ? step.sqrtPriceNextX96 < params.sqrtPriceLimitX96\\n                        : step.sqrtPriceNextX96 > params.sqrtPriceLimitX96\\n                ) ? params.sqrtPriceLimitX96 : step.sqrtPriceNextX96,\\n                state.liquidity,\\n                state.amountSpecifiedRemaining,\\n                params.fee\\n            );\\n\\n            if (exactInput) {\\n                // safe because we test that amountSpecified > amountIn + feeAmount in SwapMath\\n                unchecked {\\n                    state.amountSpecifiedRemaining -= (step.amountIn + step.feeAmount).toInt256();\\n                }\\n                state.amountCalculated = state.amountCalculated - step.amountOut.toInt256();\\n            } else {\\n                unchecked {\\n                    state.amountSpecifiedRemaining += step.amountOut.toInt256();\\n                }\\n                state.amountCalculated = state.amountCalculated + (step.amountIn + step.feeAmount).toInt256();\\n            }\\n\\n            // if the protocol fee is on, calculate how much is owed, decrement feeAmount, and increment protocolFee\\n            if (cache.protocolFee > 0) {\\n                // A: calculate the amount of the fee that should go to the protocol\\n                uint256 delta = step.feeAmount / cache.protocolFee;\\n                // A: subtract it from the regular fee and add it to the protocol fee\\n                unchecked {\\n                    step.feeAmount -= delta;\\n                    feeForProtocol += delta;\\n                }\\n            }\\n\\n            if (cache.hookFee > 0) {\\n                // step.feeAmount has already been updated to account for the protocol fee\\n                uint256 delta = step.feeAmount / cache.hookFee;\\n                unchecked {\\n                    step.feeAmount -= delta;\\n                    feeForHook += delta;\\n                }\\n            }\\n\\n            // update global fee tracker\\n            if (state.liquidity > 0) {\\n                unchecked {\\n                    state.feeGrowthGlobalX128 += FullMath.mulDiv(step.feeAmount, FixedPoint128.Q128, state.liquidity);\\n                }\\n            }\\n\\n            // shift tick if we reached the next price\\n            if (state.sqrtPriceX96 == step.sqrtPriceNextX96) {\\n                // if the tick is initialized, run the tick transition\\n                if (step.initialized) {\\n                    int128 liquidityNet = Pool.crossTick(\\n                        self,\\n                        step.tickNext,\\n                        (params.zeroForOne ? state.feeGrowthGlobalX128 : self.feeGrowthGlobal0X128),\\n                        (params.zeroForOne ? self.feeGrowthGlobal1X128 : state.feeGrowthGlobalX128)\\n                    );\\n                    // if we're moving leftward, we interpret liquidityNet as the opposite sign\\n                    // safe because liquidityNet cannot be type(int128).min\\n                    unchecked {\\n                        if (params.zeroForOne) liquidityNet = -liquidityNet;\\n                    }\\n\\n                    state.liquidity = liquidityNet < 0\\n                        ? state.liquidity - uint128(-liquidityNet)\\n                        : state.liquidity + uint128(liquidityNet);\\n                }\\n\\n                unchecked {\\n                    state.tick = params.zeroForOne ? step.tickNext - 1 : step.tickNext;\\n                }\\n            } else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {\\n                // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved\\n                state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);\\n            }\\n        }\\n\\n        (self.slot0.sqrtPriceX96, self.slot0.tick) = (state.sqrtPriceX96, state.tick);\\n\\n        // update liquidity if it changed\\n        if (cache.liquidityStart != state.liquidity) self.liquidity = state.liquidity;\\n\\n        // update fee growth global\\n        if (params.zeroForOne) {\\n            self.feeGrowthGlobal0X128 = state.feeGrowthGlobalX128;\\n        } else {\\n            self.feeGrowthGlobal1X128 = state.feeGrowthGlobalX128;\\n        }\\n\\n        unchecked {\\n            if (params.zeroForOne == exactInput) {\\n                result = toBalanceDelta(\\n                    (params.amountSpecified - state.amountSpecifiedRemaining).toInt128(),\\n                    state.amountCalculated.toInt128()\\n                );\\n            } else {\\n                result = toBalanceDelta(\\n                    state.amountCalculated.toInt128(),\\n                    (params.amountSpecified - state.amountSpecifiedRemaining).toInt128()\\n                );\\n            }\\n        }\\n    }\\n\\n    /// @notice Donates the given amount of currency0 and currency1 to the pool\\n    function donate(State storage state, uint256 amount0, uint256 amount1) internal returns (BalanceDelta delta) {\\n        if (state.liquidity == 0) revert NoLiquidityToReceiveFees();\\n        delta = toBalanceDelta(amount0.toInt128(), amount1.toInt128());\\n        unchecked {\\n            if (amount0 > 0) {\\n                state.feeGrowthGlobal0X128 += FullMath.mulDiv(amount0, FixedPoint128.Q128, state.liquidity);\\n            }\\n            if (amount1 > 0) {\\n                state.feeGrowthGlobal1X128 += FullMath.mulDiv(amount1, FixedPoint128.Q128, state.liquidity);\\n            }\\n        }\\n    }\\n\\n    /// @notice Retrieves fee growth data\\n    /// @param self The Pool state struct\\n    /// @param tickLower The lower tick boundary of the position\\n    /// @param tickUpper The upper tick boundary of the position\\n    /// @return feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries\\n    /// @return feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries\\n    function getFeeGrowthInside(State storage self, int24 tickLower, int24 tickUpper)\\n        internal\\n        view\\n        returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128)\\n    {\\n        TickInfo storage lower = self.ticks[tickLower];\\n        TickInfo storage upper = self.ticks[tickUpper];\\n        int24 tickCurrent = self.slot0.tick;\\n\\n        unchecked {\\n            if (tickCurrent < tickLower) {\\n                feeGrowthInside0X128 = lower.feeGrowthOutside0X128 - upper.feeGrowthOutside0X128;\\n                feeGrowthInside1X128 = lower.feeGrowthOutside1X128 - upper.feeGrowthOutside1X128;\\n            } else if (tickCurrent >= tickUpper) {\\n                feeGrowthInside0X128 = upper.feeGrowthOutside0X128 - lower.feeGrowthOutside0X128;\\n                feeGrowthInside1X128 = upper.feeGrowthOutside1X128 - lower.feeGrowthOutside1X128;\\n            } else {\\n                feeGrowthInside0X128 =\\n                    self.feeGrowthGlobal0X128 - lower.feeGrowthOutside0X128 - upper.feeGrowthOutside0X128;\\n                feeGrowthInside1X128 =\\n                    self.feeGrowthGlobal1X128 - lower.feeGrowthOutside1X128 - upper.feeGrowthOutside1X128;\\n            }\\n        }\\n    }\\n\\n    /// @notice Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa\\n    /// @param self The mapping containing all tick information for initialized ticks\\n    /// @param tick The tick that will be updated\\n    /// @param liquidityDelta A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left)\\n    /// @param upper true for updating a position's upper tick, or false for updating a position's lower tick\\n    /// @return flipped Whether the tick was flipped from initialized to uninitialized, or vice versa\\n    /// @return liquidityGrossAfter The total amount of  liquidity for all positions that references the tick after the update\\n    function updateTick(State storage self, int24 tick, int128 liquidityDelta, bool upper)\\n        internal\\n        returns (bool flipped, uint128 liquidityGrossAfter)\\n    {\\n        TickInfo storage info = self.ticks[tick];\\n\\n        uint128 liquidityGrossBefore;\\n        int128 liquidityNetBefore;\\n        assembly {\\n            // load first slot of info which contains liquidityGross and liquidityNet packed\\n            // where the top 128 bits are liquidityNet and the bottom 128 bits are liquidityGross\\n            let liquidity := sload(info.slot)\\n            // slice off top 128 bits of liquidity (liquidityNet) to get just liquidityGross\\n            liquidityGrossBefore := shr(128, shl(128, liquidity))\\n            // shift right 128 bits to get just liquidityNet\\n            liquidityNetBefore := shr(128, liquidity)\\n        }\\n\\n        liquidityGrossAfter = liquidityDelta < 0\\n            ? liquidityGrossBefore - uint128(-liquidityDelta)\\n            : liquidityGrossBefore + uint128(liquidityDelta);\\n\\n        flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);\\n\\n        if (liquidityGrossBefore == 0) {\\n            // by convention, we assume that all growth before a tick was initialized happened _below_ the tick\\n            if (tick <= self.slot0.tick) {\\n                info.feeGrowthOutside0X128 = self.feeGrowthGlobal0X128;\\n                info.feeGrowthOutside1X128 = self.feeGrowthGlobal1X128;\\n            }\\n        }\\n\\n        // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)\\n        int128 liquidityNet = upper ? liquidityNetBefore - liquidityDelta : liquidityNetBefore + liquidityDelta;\\n        assembly {\\n            // liquidityGrossAfter and liquidityNet are packed in the first slot of `info`\\n            // So we can store them with a single sstore by packing them ourselves first\\n            sstore(\\n                info.slot,\\n                // bitwise OR to pack liquidityGrossAfter and liquidityNet\\n                or(\\n                    // liquidityGross is in the low bits, upper bits are already 0\\n                    liquidityGrossAfter,\\n                    // shift liquidityNet to take the upper bits and lower bits get filled with 0\\n                    shl(128, liquidityNet)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @notice Derives max liquidity per tick from given tick spacing\\n    /// @dev Executed within the pool constructor\\n    /// @param tickSpacing The amount of required tick separation, realized in multiples of `tickSpacing`\\n    ///     e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ...\\n    /// @return The max liquidity per tick\\n    function tickSpacingToMaxLiquidityPerTick(int24 tickSpacing) internal pure returns (uint128) {\\n        unchecked {\\n            return uint128(\\n                (type(uint128).max * uint256(int256(tickSpacing)))\\n                    / uint256(int256(TickMath.MAX_TICK * 2 + tickSpacing))\\n            );\\n        }\\n    }\\n\\n    /// @notice Clears tick data\\n    /// @param self The mapping containing all initialized tick information for initialized ticks\\n    /// @param tick The tick that will be cleared\\n    function clearTick(State storage self, int24 tick) internal {\\n        delete self.ticks[tick];\\n    }\\n\\n    /// @notice Transitions to next tick as needed by price movement\\n    /// @param self The Pool state struct\\n    /// @param tick The destination tick of the transition\\n    /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0\\n    /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1\\n    /// @return liquidityNet The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left)\\n    function crossTick(State storage self, int24 tick, uint256 feeGrowthGlobal0X128, uint256 feeGrowthGlobal1X128)\\n        internal\\n        returns (int128 liquidityNet)\\n    {\\n        unchecked {\\n            TickInfo storage info = self.ticks[tick];\\n            info.feeGrowthOutside0X128 = feeGrowthGlobal0X128 - info.feeGrowthOutside0X128;\\n            info.feeGrowthOutside1X128 = feeGrowthGlobal1X128 - info.feeGrowthOutside1X128;\\n            liquidityNet = info.liquidityNet;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe68c53367349bf7d5ec53f10abbe32effabe41c288eea6b42de67941104e4bc7\",\"license\":\"BUSL-1.1\"},\"@uniswap/v4-core/contracts/libraries/Position.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.20;\\n\\nimport {FullMath} from \\\"./FullMath.sol\\\";\\nimport {FixedPoint128} from \\\"./FixedPoint128.sol\\\";\\n\\n/// @title Position\\n/// @notice Positions represent an owner address' liquidity between a lower and upper tick boundary\\n/// @dev Positions store additional state for tracking fees owed to the position\\nlibrary Position {\\n    /// @notice Cannot update a position with no liquidity\\n    error CannotUpdateEmptyPosition();\\n\\n    // info stored for each user's position\\n    struct Info {\\n        // the amount of liquidity owned by this position\\n        uint128 liquidity;\\n        // fee growth per unit of liquidity as of the last update to liquidity or fees owed\\n        uint256 feeGrowthInside0LastX128;\\n        uint256 feeGrowthInside1LastX128;\\n    }\\n\\n    /// @notice Returns the Info struct of a position, given an owner and position boundaries\\n    /// @param self The mapping containing all user positions\\n    /// @param owner The address of the position owner\\n    /// @param tickLower The lower tick boundary of the position\\n    /// @param tickUpper The upper tick boundary of the position\\n    /// @return position The position info struct of the given owners' position\\n    function get(mapping(bytes32 => Info) storage self, address owner, int24 tickLower, int24 tickUpper)\\n        internal\\n        view\\n        returns (Position.Info storage position)\\n    {\\n        position = self[keccak256(abi.encodePacked(owner, tickLower, tickUpper))];\\n    }\\n\\n    /// @notice Credits accumulated fees to a user's position\\n    /// @param self The individual position to update\\n    /// @param liquidityDelta The change in pool liquidity as a result of the position update\\n    /// @param feeGrowthInside0X128 The all-time fee growth in currency0, per unit of liquidity, inside the position's tick boundaries\\n    /// @param feeGrowthInside1X128 The all-time fee growth in currency1, per unit of liquidity, inside the position's tick boundaries\\n    /// @return feesOwed0 The amount of currency0 owed to the position owner\\n    /// @return feesOwed1 The amount of currency1 owed to the position owner\\n    function update(\\n        Info storage self,\\n        int128 liquidityDelta,\\n        uint256 feeGrowthInside0X128,\\n        uint256 feeGrowthInside1X128\\n    ) internal returns (uint256 feesOwed0, uint256 feesOwed1) {\\n        Info memory _self = self;\\n\\n        uint128 liquidityNext;\\n        if (liquidityDelta == 0) {\\n            if (_self.liquidity == 0) revert CannotUpdateEmptyPosition(); // disallow pokes for 0 liquidity positions\\n            liquidityNext = _self.liquidity;\\n        } else {\\n            liquidityNext = liquidityDelta < 0\\n                ? _self.liquidity - uint128(-liquidityDelta)\\n                : _self.liquidity + uint128(liquidityDelta);\\n        }\\n\\n        // calculate accumulated fees. overflow in the subtraction of fee growth is expected\\n        unchecked {\\n            feesOwed0 = FullMath.mulDiv(\\n                feeGrowthInside0X128 - _self.feeGrowthInside0LastX128, _self.liquidity, FixedPoint128.Q128\\n            );\\n            feesOwed1 = FullMath.mulDiv(\\n                feeGrowthInside1X128 - _self.feeGrowthInside1LastX128, _self.liquidity, FixedPoint128.Q128\\n            );\\n        }\\n\\n        // update the position\\n        if (liquidityDelta != 0) self.liquidity = liquidityNext;\\n        self.feeGrowthInside0LastX128 = feeGrowthInside0X128;\\n        self.feeGrowthInside1LastX128 = feeGrowthInside1X128;\\n    }\\n}\\n\",\"keccak256\":\"0x1319e4c172e31427c3b3521dd3c9c9c3949da22e25c9919ae57c47a8c9328e43\",\"license\":\"BUSL-1.1\"},\"@uniswap/v4-core/contracts/libraries/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\n/// @title Safe casting methods\\n/// @notice Contains methods for safely casting between types\\nlibrary SafeCast {\\n    /// @notice Cast a uint256 to a uint160, revert on overflow\\n    /// @param y The uint256 to be downcasted\\n    /// @return z The downcasted integer, now type uint160\\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\\n        require((z = uint160(y)) == y);\\n    }\\n\\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\\n    /// @param y The int256 to be downcasted\\n    /// @return z The downcasted integer, now type int128\\n    function toInt128(int256 y) internal pure returns (int128 z) {\\n        require((z = int128(y)) == y);\\n    }\\n\\n    /// @notice Cast a uint256 to a int256, revert on overflow\\n    /// @param y The uint256 to be casted\\n    /// @return z The casted integer, now type int256\\n    function toInt256(uint256 y) internal pure returns (int256 z) {\\n        require(y <= uint256(type(int256).max));\\n        z = int256(y);\\n    }\\n\\n    /// @notice Cast a uint256 to a int128, revert on overflow\\n    /// @param y The uint256 to be downcasted\\n    /// @return z The downcasted integer, now type int128\\n    function toInt128(uint256 y) internal pure returns (int128 z) {\\n        require(y <= uint128(type(int128).max));\\n        z = int128(int256(y));\\n    }\\n}\\n\",\"keccak256\":\"0xb459cbf9f2cda4c38c11916e888cc2afbe4297c5ae6f50a0976eb83ed0dc9b25\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/libraries/SqrtPriceMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {SafeCast} from \\\"./SafeCast.sol\\\";\\n\\nimport {FullMath} from \\\"./FullMath.sol\\\";\\nimport {UnsafeMath} from \\\"./UnsafeMath.sol\\\";\\nimport {FixedPoint96} from \\\"./FixedPoint96.sol\\\";\\n\\n/// @title Functions based on Q64.96 sqrt price and liquidity\\n/// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas\\nlibrary SqrtPriceMath {\\n    using SafeCast for uint256;\\n\\n    /// @notice Gets the next sqrt price given a delta of currency0\\n    /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least\\n    /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the\\n    /// price less in order to not send too much output.\\n    /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),\\n    /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).\\n    /// @param sqrtPX96 The starting price, i.e. before accounting for the currency0 delta\\n    /// @param liquidity The amount of usable liquidity\\n    /// @param amount How much of currency0 to add or remove from virtual reserves\\n    /// @param add Whether to add or remove the amount of currency0\\n    /// @return The price after adding or removing amount, depending on add\\n    function getNextSqrtPriceFromAmount0RoundingUp(uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add)\\n        internal\\n        pure\\n        returns (uint160)\\n    {\\n        // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price\\n        if (amount == 0) return sqrtPX96;\\n        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\\n\\n        if (add) {\\n            unchecked {\\n                uint256 product;\\n                if ((product = amount * sqrtPX96) / amount == sqrtPX96) {\\n                    uint256 denominator = numerator1 + product;\\n                    if (denominator >= numerator1) {\\n                        // always fits in 160 bits\\n                        return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));\\n                    }\\n                }\\n            }\\n            // denominator is checked for overflow\\n            return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96) + amount));\\n        } else {\\n            unchecked {\\n                uint256 product;\\n                // if the product overflows, we know the denominator underflows\\n                // in addition, we must check that the denominator does not underflow\\n                require((product = amount * sqrtPX96) / amount == sqrtPX96 && numerator1 > product);\\n                uint256 denominator = numerator1 - product;\\n                return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();\\n            }\\n        }\\n    }\\n\\n    /// @notice Gets the next sqrt price given a delta of currency1\\n    /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least\\n    /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the\\n    /// price less in order to not send too much output.\\n    /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity\\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the currency1 delta\\n    /// @param liquidity The amount of usable liquidity\\n    /// @param amount How much of currency1 to add, or remove, from virtual reserves\\n    /// @param add Whether to add, or remove, the amount of currency1\\n    /// @return The price after adding or removing `amount`\\n    function getNextSqrtPriceFromAmount1RoundingDown(uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add)\\n        internal\\n        pure\\n        returns (uint160)\\n    {\\n        // if we're adding (subtracting), rounding down requires rounding the quotient down (up)\\n        // in both cases, avoid a mulDiv for most inputs\\n        if (add) {\\n            uint256 quotient = (\\n                amount <= type(uint160).max\\n                    ? (amount << FixedPoint96.RESOLUTION) / liquidity\\n                    : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)\\n            );\\n\\n            return (uint256(sqrtPX96) + quotient).toUint160();\\n        } else {\\n            uint256 quotient = (\\n                amount <= type(uint160).max\\n                    ? UnsafeMath.divRoundingUp(amount << FixedPoint96.RESOLUTION, liquidity)\\n                    : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity)\\n            );\\n\\n            require(sqrtPX96 > quotient);\\n            // always fits 160 bits\\n            return uint160(sqrtPX96 - quotient);\\n        }\\n    }\\n\\n    /// @notice Gets the next sqrt price given an input amount of currency0 or currency1\\n    /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds\\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount\\n    /// @param liquidity The amount of usable liquidity\\n    /// @param amountIn How much of currency0, or currency1, is being swapped in\\n    /// @param zeroForOne Whether the amount in is currency0 or currency1\\n    /// @return sqrtQX96 The price after adding the input amount to currency0 or currency1\\n    function getNextSqrtPriceFromInput(uint160 sqrtPX96, uint128 liquidity, uint256 amountIn, bool zeroForOne)\\n        internal\\n        pure\\n        returns (uint160 sqrtQX96)\\n    {\\n        require(sqrtPX96 > 0);\\n        require(liquidity > 0);\\n\\n        // round to make sure that we don't pass the target price\\n        return zeroForOne\\n            ? getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)\\n            : getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);\\n    }\\n\\n    /// @notice Gets the next sqrt price given an output amount of currency0 or currency1\\n    /// @dev Throws if price or liquidity are 0 or the next price is out of bounds\\n    /// @param sqrtPX96 The starting price before accounting for the output amount\\n    /// @param liquidity The amount of usable liquidity\\n    /// @param amountOut How much of currency0, or currency1, is being swapped out\\n    /// @param zeroForOne Whether the amount out is currency0 or currency1\\n    /// @return sqrtQX96 The price after removing the output amount of currency0 or currency1\\n    function getNextSqrtPriceFromOutput(uint160 sqrtPX96, uint128 liquidity, uint256 amountOut, bool zeroForOne)\\n        internal\\n        pure\\n        returns (uint160 sqrtQX96)\\n    {\\n        require(sqrtPX96 > 0);\\n        require(liquidity > 0);\\n\\n        // round to make sure that we pass the target price\\n        return zeroForOne\\n            ? getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)\\n            : getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);\\n    }\\n\\n    /// @notice Gets the amount0 delta between two prices\\n    /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),\\n    /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\\n    /// @param sqrtRatioAX96 A sqrt price\\n    /// @param sqrtRatioBX96 Another sqrt price\\n    /// @param liquidity The amount of usable liquidity\\n    /// @param roundUp Whether to round the amount up or down\\n    /// @return amount0 Amount of currency0 required to cover a position of size liquidity between the two passed prices\\n    function getAmount0Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity, bool roundUp)\\n        internal\\n        pure\\n        returns (uint256 amount0)\\n    {\\n        unchecked {\\n            if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n            uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\\n            uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;\\n\\n            require(sqrtRatioAX96 > 0);\\n\\n            return roundUp\\n                ? UnsafeMath.divRoundingUp(FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96), sqrtRatioAX96)\\n                : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) / sqrtRatioAX96;\\n        }\\n    }\\n\\n    /// @notice Gets the amount1 delta between two prices\\n    /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))\\n    /// @param sqrtRatioAX96 A sqrt price\\n    /// @param sqrtRatioBX96 Another sqrt price\\n    /// @param liquidity The amount of usable liquidity\\n    /// @param roundUp Whether to round the amount up, or down\\n    /// @return amount1 Amount of currency1 required to cover a position of size liquidity between the two passed prices\\n    function getAmount1Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity, bool roundUp)\\n        internal\\n        pure\\n        returns (uint256 amount1)\\n    {\\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n        return roundUp\\n            ? FullMath.mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96)\\n            : FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\\n    }\\n\\n    /// @notice Helper that gets signed currency0 delta\\n    /// @param sqrtRatioAX96 A sqrt price\\n    /// @param sqrtRatioBX96 Another sqrt price\\n    /// @param liquidity The change in liquidity for which to compute the amount0 delta\\n    /// @return amount0 Amount of currency0 corresponding to the passed liquidityDelta between the two prices\\n    function getAmount0Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, int128 liquidity)\\n        internal\\n        pure\\n        returns (int256 amount0)\\n    {\\n        unchecked {\\n            return liquidity < 0\\n                ? -getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\\n                : getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\\n        }\\n    }\\n\\n    /// @notice Helper that gets signed currency1 delta\\n    /// @param sqrtRatioAX96 A sqrt price\\n    /// @param sqrtRatioBX96 Another sqrt price\\n    /// @param liquidity The change in liquidity for which to compute the amount1 delta\\n    /// @return amount1 Amount of currency1 corresponding to the passed liquidityDelta between the two prices\\n    function getAmount1Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, int128 liquidity)\\n        internal\\n        pure\\n        returns (int256 amount1)\\n    {\\n        unchecked {\\n            return liquidity < 0\\n                ? -getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\\n                : getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x62cb03c7ce6ce037c82fa74e5aabb2431d6b4ddbca1458efdabf5d6af9ca6f90\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/libraries/SwapMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {FullMath} from \\\"./FullMath.sol\\\";\\nimport {SqrtPriceMath} from \\\"./SqrtPriceMath.sol\\\";\\n\\n/// @title Computes the result of a swap within ticks\\n/// @notice Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.\\nlibrary SwapMath {\\n    /// @notice Computes the result of swapping some amount in, or amount out, given the parameters of the swap\\n    /// @dev The fee, plus the amount in, will never exceed the amount remaining if the swap's `amountSpecified` is positive\\n    /// @param sqrtRatioCurrentX96 The current sqrt price of the pool\\n    /// @param sqrtRatioTargetX96 The price that cannot be exceeded, from which the direction of the swap is inferred\\n    /// @param liquidity The usable liquidity\\n    /// @param amountRemaining How much input or output amount is remaining to be swapped in/out\\n    /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip\\n    /// @return sqrtRatioNextX96 The price after swapping the amount in/out, not to exceed the price target\\n    /// @return amountIn The amount to be swapped in, of either currency0 or currency1, based on the direction of the swap\\n    /// @return amountOut The amount to be received, of either currency0 or currency1, based on the direction of the swap\\n    /// @return feeAmount The amount of input that will be taken as a fee\\n    function computeSwapStep(\\n        uint160 sqrtRatioCurrentX96,\\n        uint160 sqrtRatioTargetX96,\\n        uint128 liquidity,\\n        int256 amountRemaining,\\n        uint24 feePips\\n    ) internal pure returns (uint160 sqrtRatioNextX96, uint256 amountIn, uint256 amountOut, uint256 feeAmount) {\\n        unchecked {\\n            bool zeroForOne = sqrtRatioCurrentX96 >= sqrtRatioTargetX96;\\n            bool exactIn = amountRemaining >= 0;\\n\\n            if (exactIn) {\\n                uint256 amountRemainingLessFee = FullMath.mulDiv(uint256(amountRemaining), 1e6 - feePips, 1e6);\\n                amountIn = zeroForOne\\n                    ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true)\\n                    : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true);\\n                if (amountRemainingLessFee >= amountIn) {\\n                    sqrtRatioNextX96 = sqrtRatioTargetX96;\\n                } else {\\n                    sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(\\n                        sqrtRatioCurrentX96, liquidity, amountRemainingLessFee, zeroForOne\\n                    );\\n                }\\n            } else {\\n                amountOut = zeroForOne\\n                    ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false)\\n                    : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false);\\n                if (uint256(-amountRemaining) >= amountOut) {\\n                    sqrtRatioNextX96 = sqrtRatioTargetX96;\\n                } else {\\n                    sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(\\n                        sqrtRatioCurrentX96, liquidity, uint256(-amountRemaining), zeroForOne\\n                    );\\n                }\\n            }\\n\\n            bool max = sqrtRatioTargetX96 == sqrtRatioNextX96;\\n\\n            // get the input/output amounts\\n            if (zeroForOne) {\\n                amountIn = max && exactIn\\n                    ? amountIn\\n                    : SqrtPriceMath.getAmount0Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);\\n                amountOut = max && !exactIn\\n                    ? amountOut\\n                    : SqrtPriceMath.getAmount1Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false);\\n            } else {\\n                amountIn = max && exactIn\\n                    ? amountIn\\n                    : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, true);\\n                amountOut = max && !exactIn\\n                    ? amountOut\\n                    : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, false);\\n            }\\n\\n            // cap the output amount to not exceed the remaining output amount\\n            if (!exactIn && amountOut > uint256(-amountRemaining)) {\\n                amountOut = uint256(-amountRemaining);\\n            }\\n\\n            if (exactIn && sqrtRatioNextX96 != sqrtRatioTargetX96) {\\n                // we didn't reach the target, so take the remainder of the maximum input as fee\\n                feeAmount = uint256(amountRemaining) - amountIn;\\n            } else {\\n                feeAmount = FullMath.mulDivRoundingUp(amountIn, feePips, 1e6 - feePips);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xac5b75b36ff928e88cbec828bdc9db03e681cc3b337d5d7f6be9fd617b3fef7f\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/libraries/TickBitmap.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {BitMath} from \\\"./BitMath.sol\\\";\\n\\n/// @title Packed tick initialized state library\\n/// @notice Stores a packed mapping of tick index to its initialized state\\n/// @dev The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.\\nlibrary TickBitmap {\\n    /// @notice Thrown when the tick is not enumerated by the tick spacing\\n    /// @param tick the invalid tick\\n    /// @param tickSpacing The tick spacing of the pool\\n    error TickMisaligned(int24 tick, int24 tickSpacing);\\n\\n    /// @notice Computes the position in the mapping where the initialized bit for a tick lives\\n    /// @param tick The tick for which to compute the position\\n    /// @return wordPos The key in the mapping containing the word in which the bit is stored\\n    /// @return bitPos The bit position in the word where the flag is stored\\n    function position(int24 tick) private pure returns (int16 wordPos, uint8 bitPos) {\\n        unchecked {\\n            wordPos = int16(tick >> 8);\\n            bitPos = uint8(int8(tick % 256));\\n        }\\n    }\\n\\n    /// @notice Flips the initialized state for a given tick from false to true, or vice versa\\n    /// @param self The mapping in which to flip the tick\\n    /// @param tick The tick to flip\\n    /// @param tickSpacing The spacing between usable ticks\\n    function flipTick(mapping(int16 => uint256) storage self, int24 tick, int24 tickSpacing) internal {\\n        unchecked {\\n            if (tick % tickSpacing != 0) revert TickMisaligned(tick, tickSpacing); // ensure that the tick is spaced\\n            (int16 wordPos, uint8 bitPos) = position(tick / tickSpacing);\\n            uint256 mask = 1 << bitPos;\\n            self[wordPos] ^= mask;\\n        }\\n    }\\n\\n    /// @notice Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either\\n    /// to the left (less than or equal to) or right (greater than) of the given tick\\n    /// @param self The mapping in which to compute the next initialized tick\\n    /// @param tick The starting tick\\n    /// @param tickSpacing The spacing between usable ticks\\n    /// @param lte Whether to search for the next initialized tick to the left (less than or equal to the starting tick)\\n    /// @return next The next initialized or uninitialized tick up to 256 ticks away from the current tick\\n    /// @return initialized Whether the next tick is initialized, as the function only searches within up to 256 ticks\\n    function nextInitializedTickWithinOneWord(\\n        mapping(int16 => uint256) storage self,\\n        int24 tick,\\n        int24 tickSpacing,\\n        bool lte\\n    ) internal view returns (int24 next, bool initialized) {\\n        unchecked {\\n            int24 compressed = tick / tickSpacing;\\n            if (tick < 0 && tick % tickSpacing != 0) compressed--; // round towards negative infinity\\n\\n            if (lte) {\\n                (int16 wordPos, uint8 bitPos) = position(compressed);\\n                // all the 1s at or to the right of the current bitPos\\n                uint256 mask = (1 << bitPos) - 1 + (1 << bitPos);\\n                uint256 masked = self[wordPos] & mask;\\n\\n                // if there are no initialized ticks to the right of or at the current tick, return rightmost in the word\\n                initialized = masked != 0;\\n                // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\\n                next = initialized\\n                    ? (compressed - int24(uint24(bitPos - BitMath.mostSignificantBit(masked)))) * tickSpacing\\n                    : (compressed - int24(uint24(bitPos))) * tickSpacing;\\n            } else {\\n                // start from the word of the next tick, since the current tick state doesn't matter\\n                (int16 wordPos, uint8 bitPos) = position(compressed + 1);\\n                // all the 1s at or to the left of the bitPos\\n                uint256 mask = ~((1 << bitPos) - 1);\\n                uint256 masked = self[wordPos] & mask;\\n\\n                // if there are no initialized ticks to the left of the current tick, return leftmost in the word\\n                initialized = masked != 0;\\n                // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\\n                next = initialized\\n                    ? (compressed + 1 + int24(uint24(BitMath.leastSignificantBit(masked) - bitPos))) * tickSpacing\\n                    : (compressed + 1 + int24(uint24(type(uint8).max - bitPos))) * tickSpacing;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7cccb8dff4c76da872a827f1549dc44cdff384d123e77a5361a02a31902bf15c\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/libraries/TickMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\n/// @title Math library for computing sqrt prices from ticks and vice versa\\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\\n/// prices between 2**-128 and 2**128\\nlibrary TickMath {\\n    /// @notice Thrown when the tick passed to #getSqrtRatioAtTick is not between MIN_TICK and MAX_TICK\\n    error InvalidTick();\\n    /// @notice Thrown when the ratio passed to #getTickAtSqrtRatio does not correspond to a price between MIN_TICK and MAX_TICK\\n    error InvalidSqrtRatio();\\n\\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\n    int24 internal constant MIN_TICK = -887272;\\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\n    int24 internal constant MAX_TICK = -MIN_TICK;\\n\\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\\n\\n    /// @notice Given a tickSpacing, compute the maximum usable tick\\n    function maxUsableTick(int24 tickSpacing) internal pure returns (int24) {\\n        unchecked {\\n            return (MAX_TICK / tickSpacing) * tickSpacing;\\n        }\\n    }\\n\\n    /// @notice Given a tickSpacing, compute the minimum usable tick\\n    function minUsableTick(int24 tickSpacing) internal pure returns (int24) {\\n        unchecked {\\n            return (MIN_TICK / tickSpacing) * tickSpacing;\\n        }\\n    }\\n\\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\\n    /// @dev Throws if |tick| > max tick\\n    /// @param tick The input tick for the above formula\\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (currency1/currency0)\\n    /// at the given tick\\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\\n        unchecked {\\n            uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\\n            if (absTick > uint256(int256(MAX_TICK))) revert InvalidTick();\\n\\n            uint256 ratio =\\n                absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\\n            if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\n            if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n            if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n            if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n            if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n            if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n            if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n            if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n            if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n            if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n            if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n            if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n            if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n            if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n            if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n            if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n            if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n            if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n            if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n\\n            if (tick > 0) ratio = type(uint256).max / ratio;\\n\\n            // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\n            // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\n            // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\n            sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\\n        }\\n    }\\n\\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\\n    /// ever return.\\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\\n        unchecked {\\n            // second inequality must be < because the price can never reach the price at the max tick\\n            if (sqrtPriceX96 < MIN_SQRT_RATIO || sqrtPriceX96 >= MAX_SQRT_RATIO) revert InvalidSqrtRatio();\\n            uint256 ratio = uint256(sqrtPriceX96) << 32;\\n\\n            uint256 r = ratio;\\n            uint256 msb = 0;\\n\\n            assembly {\\n                let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(5, gt(r, 0xFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(4, gt(r, 0xFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(3, gt(r, 0xFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(2, gt(r, 0xF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(1, gt(r, 0x3))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := gt(r, 0x1)\\n                msb := or(msb, f)\\n            }\\n\\n            if (msb >= 128) r = ratio >> (msb - 127);\\n            else r = ratio << (127 - msb);\\n\\n            int256 log_2 = (int256(msb) - 128) << 64;\\n\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(63, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(62, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(61, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(60, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(59, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(58, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(57, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(56, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(55, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(54, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(53, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(52, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(51, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(50, f))\\n            }\\n\\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\\n\\n            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\\n            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\\n\\n            tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xadffea78a3eed37613b57766d87c0bdb9454d2df39de90d7a450e4a8b3207e56\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/libraries/UnsafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\n/// @title Math functions that do not check inputs or outputs\\n/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks\\nlibrary UnsafeMath {\\n    /// @notice Returns ceil(x / y)\\n    /// @dev division by 0 has unspecified behavior, and must be checked externally\\n    /// @param x The dividend\\n    /// @param y The divisor\\n    /// @return z The quotient, ceil(x / y)\\n    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            assembly {\\n                z := add(div(x, y), gt(mod(x, y), 0))\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2a8cb75af05f8557b698b089a0ab19e24279fffb7e87cddf5794404c7eaf1c69\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/types/BalanceDelta.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\ntype BalanceDelta is int256;\\n\\nusing {add as +, sub as -} for BalanceDelta global;\\nusing BalanceDeltaLibrary for BalanceDelta global;\\n\\nfunction toBalanceDelta(int128 _amount0, int128 _amount1) pure returns (BalanceDelta balanceDelta) {\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n        balanceDelta :=\\n            or(shl(128, _amount0), and(0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff, _amount1))\\n    }\\n}\\n\\nfunction add(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta) {\\n    return toBalanceDelta(a.amount0() + b.amount0(), a.amount1() + b.amount1());\\n}\\n\\nfunction sub(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta) {\\n    return toBalanceDelta(a.amount0() - b.amount0(), a.amount1() - b.amount1());\\n}\\n\\nlibrary BalanceDeltaLibrary {\\n    function amount0(BalanceDelta balanceDelta) internal pure returns (int128 _amount0) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            _amount0 := shr(128, balanceDelta)\\n        }\\n    }\\n\\n    function amount1(BalanceDelta balanceDelta) internal pure returns (int128 _amount1) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            _amount1 := balanceDelta\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb88fc16f2ae715bd796e5cdb77c2297117f18ce2183288ae4680d7f20cce5f85\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/types/Currency.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {IERC20Minimal} from \\\"../interfaces/external/IERC20Minimal.sol\\\";\\n\\ntype Currency is address;\\n\\nusing {greaterThan as >, lessThan as <, equals as ==} for Currency global;\\n\\nfunction equals(Currency currency, Currency other) pure returns (bool) {\\n    return Currency.unwrap(currency) == Currency.unwrap(other);\\n}\\n\\nfunction greaterThan(Currency currency, Currency other) pure returns (bool) {\\n    return Currency.unwrap(currency) > Currency.unwrap(other);\\n}\\n\\nfunction lessThan(Currency currency, Currency other) pure returns (bool) {\\n    return Currency.unwrap(currency) < Currency.unwrap(other);\\n}\\n\\n/// @title CurrencyLibrary\\n/// @dev This library allows for transferring and holding native tokens and ERC20 tokens\\nlibrary CurrencyLibrary {\\n    using CurrencyLibrary for Currency;\\n\\n    /// @notice Thrown when a native transfer fails\\n    error NativeTransferFailed();\\n\\n    /// @notice Thrown when an ERC20 transfer fails\\n    error ERC20TransferFailed();\\n\\n    Currency public constant NATIVE = Currency.wrap(address(0));\\n\\n    function transfer(Currency currency, address to, uint256 amount) internal {\\n        // implementation from\\n        // https://github.com/transmissions11/solmate/blob/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/SafeTransferLib.sol\\n\\n        bool success;\\n        if (currency.isNative()) {\\n            assembly {\\n                // Transfer the ETH and store if it succeeded or not.\\n                success := call(gas(), to, amount, 0, 0, 0, 0)\\n            }\\n\\n            if (!success) revert NativeTransferFailed();\\n        } else {\\n            assembly {\\n                // We'll write our calldata to this slot below, but restore it later.\\n                let memPointer := mload(0x40)\\n\\n                // Write the abi-encoded calldata into memory, beginning with the function selector.\\n                mstore(0, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n                mstore(4, to) // Append the \\\"to\\\" argument.\\n                mstore(36, amount) // Append the \\\"amount\\\" argument.\\n\\n                success :=\\n                    and(\\n                        // Set success to whether the call reverted, if not we check it either\\n                        // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                        or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                        // We use 68 because that's the total length of our calldata (4 + 32 * 2)\\n                        // Counterintuitively, this call() must be positioned after the or() in the\\n                        // surrounding and() because and() evaluates its arguments from right to left.\\n                        call(gas(), currency, 0, 0, 68, 0, 32)\\n                    )\\n\\n                mstore(0x60, 0) // Restore the zero slot to zero.\\n                mstore(0x40, memPointer) // Restore the memPointer.\\n            }\\n\\n            if (!success) revert ERC20TransferFailed();\\n        }\\n    }\\n\\n    function balanceOfSelf(Currency currency) internal view returns (uint256) {\\n        if (currency.isNative()) {\\n            return address(this).balance;\\n        } else {\\n            return IERC20Minimal(Currency.unwrap(currency)).balanceOf(address(this));\\n        }\\n    }\\n\\n    function balanceOf(Currency currency, address owner) internal view returns (uint256) {\\n        if (currency.isNative()) {\\n            return owner.balance;\\n        } else {\\n            return IERC20Minimal(Currency.unwrap(currency)).balanceOf(owner);\\n        }\\n    }\\n\\n    function isNative(Currency currency) internal pure returns (bool) {\\n        return Currency.unwrap(currency) == Currency.unwrap(NATIVE);\\n    }\\n\\n    function toId(Currency currency) internal pure returns (uint256) {\\n        return uint160(Currency.unwrap(currency));\\n    }\\n\\n    function fromId(uint256 id) internal pure returns (Currency) {\\n        return Currency.wrap(address(uint160(id)));\\n    }\\n}\\n\",\"keccak256\":\"0x008a7aeff6cdb7709a8e5893c9e9895a8a7ad594a0605586174e576b9888ff80\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/types/PoolId.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.20;\\n\\nimport {PoolKey} from \\\"./PoolKey.sol\\\";\\n\\ntype PoolId is bytes32;\\n\\n/// @notice Library for computing the ID of a pool\\nlibrary PoolIdLibrary {\\n    function toId(PoolKey memory poolKey) internal pure returns (PoolId) {\\n        return PoolId.wrap(keccak256(abi.encode(poolKey)));\\n    }\\n}\\n\",\"keccak256\":\"0xd28e4ac2a0874b5372ab3873a263701ce625a840fc563c63d5ad8f7b3272f325\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v4-core/contracts/types/PoolKey.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.19;\\n\\nimport {Currency} from \\\"./Currency.sol\\\";\\nimport {IHooks} from \\\"../interfaces/IHooks.sol\\\";\\n\\n/// @notice Returns the key for identifying a pool\\nstruct PoolKey {\\n    /// @notice The lower currency of the pool, sorted numerically\\n    Currency currency0;\\n    /// @notice The higher currency of the pool, sorted numerically\\n    Currency currency1;\\n    /// @notice The pool swap fee, capped at 1_000_000. The upper 4 bits determine if the hook sets any fees.\\n    uint24 fee;\\n    /// @notice Ticks that involve positions must be a multiple of tick spacing\\n    int24 tickSpacing;\\n    /// @notice The hooks of the pool\\n    IHooks hooks;\\n}\\n\",\"keccak256\":\"0x4928c59e15db5af3bff68f4d9243ebe11a1dc4a4cbfa57c564db376086a902ce\",\"license\":\"GPL-2.0-or-later\"},\"contracts/Hooks/Utils/BaseHook.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.19;\\n\\nimport {Hooks} from \\\"@uniswap/v4-core/contracts/libraries/Hooks.sol\\\";\\nimport {IPoolManager} from \\\"@uniswap/v4-core/contracts/interfaces/IPoolManager.sol\\\";\\nimport {IHooks} from \\\"@uniswap/v4-core/contracts/interfaces/IHooks.sol\\\";\\nimport {BalanceDelta} from \\\"@uniswap/v4-core/contracts/types/BalanceDelta.sol\\\";\\nimport {PoolKey} from \\\"@uniswap/v4-core/contracts/types/PoolKey.sol\\\";\\n\\nabstract contract BaseHook is IHooks {\\n    error NotPoolManager();\\n    error NotSelf();\\n    error InvalidPool();\\n    error LockFailure();\\n    error HookNotImplemented();\\n\\n    /// @notice The address of the pool manager\\n    IPoolManager public immutable poolManager;\\n\\n    constructor(IPoolManager _poolManager) {\\n        poolManager = _poolManager;\\n        validateHookAddress(this);\\n    }\\n\\n    /// @dev Only the pool manager may call this function\\n    modifier poolManagerOnly() {\\n        if (msg.sender != address(poolManager)) revert NotPoolManager();\\n        _;\\n    }\\n\\n    /// @dev Only this address may call this function\\n    modifier selfOnly() {\\n        if (msg.sender != address(this)) revert NotSelf();\\n        _;\\n    }\\n\\n    /// @dev Only pools with hooks set to this contract may call this function\\n    modifier onlyValidPools(IHooks hooks) {\\n        if (hooks != this) revert InvalidPool();\\n        _;\\n    }\\n\\n    function getHooksCalls() public pure virtual returns (Hooks.Calls memory);\\n\\n    // this function is virtual so that we can override it during testing,\\n    // which allows us to deploy an implementation to any address\\n    // and then etch the bytecode into the correct address\\n    function validateHookAddress(BaseHook _this) internal pure virtual {\\n        Hooks.validateHookAddress(_this, getHooksCalls());\\n    }\\n\\n    function lockAcquired(\\n        bytes calldata data\\n    ) external virtual poolManagerOnly returns (bytes memory) {\\n        (bool success, bytes memory returnData) = address(this).call(data);\\n        if (success) return returnData;\\n        if (returnData.length == 0) revert LockFailure();\\n        // if the call failed, bubble up the reason\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            revert(add(returnData, 32), mload(returnData))\\n        }\\n    }\\n\\n    function beforeInitialize(\\n        address,\\n        PoolKey calldata,\\n        uint160,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        revert HookNotImplemented();\\n    }\\n\\n    function afterInitialize(\\n        address,\\n        PoolKey calldata,\\n        uint160,\\n        int24,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        revert HookNotImplemented();\\n    }\\n\\n    function beforeModifyPosition(\\n        address,\\n        PoolKey calldata,\\n        IPoolManager.ModifyPositionParams calldata,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        revert HookNotImplemented();\\n    }\\n\\n    function afterModifyPosition(\\n        address,\\n        PoolKey calldata,\\n        IPoolManager.ModifyPositionParams calldata,\\n        BalanceDelta,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        revert HookNotImplemented();\\n    }\\n\\n    function beforeSwap(\\n        address,\\n        PoolKey calldata,\\n        IPoolManager.SwapParams calldata,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        revert HookNotImplemented();\\n    }\\n\\n    function afterSwap(\\n        address,\\n        PoolKey calldata,\\n        IPoolManager.SwapParams calldata,\\n        BalanceDelta,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        revert HookNotImplemented();\\n    }\\n\\n    function beforeDonate(\\n        address,\\n        PoolKey calldata,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        revert HookNotImplemented();\\n    }\\n\\n    function afterDonate(\\n        address,\\n        PoolKey calldata,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        revert HookNotImplemented();\\n    }\\n}\\n\",\"keccak256\":\"0xe414af25e6124fd95767c4457d17fb65b0e3e4fd9e054ede3e2b1e4b30d463a8\",\"license\":\"UNLICENSED\"},\"contracts/Hooks/Utils/HooksFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\nimport \\\"../../Manager.sol\\\";\\nimport {IPoolManager} from \\\"@uniswap/v4-core/contracts/interfaces/IPoolManager.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\ncontract UniswapHooksFactory {\\n    address[] public hooks;\\n\\n    function deploy(\\n        address IUniswapInteract,\\n        address poolManager,\\n        address IMailbox,\\n        address IInterchainGasPayMaster,\\n        bytes32 salt\\n    ) external {\\n        console.log(\\\"deploying hooks...\\\");\\n        hooks.push(\\n            address(\\n                new Manager{salt: salt}(\\n                    IUniswapInteract,\\n                    poolManager,\\n                    IMailbox,\\n                    IInterchainGasPayMaster\\n                )\\n            )\\n        );\\n    }\\n\\n    function getPrecomputedHookAddress(\\n        address owner,\\n        address uniswapInteraction,\\n        address poolManager,\\n        address mailBox,\\n        address igp,\\n        bytes32 salt\\n    ) external view returns (address) {\\n        //Creation code + constructor argument\\n        bytes32 bytecodeHash = keccak256(\\n            abi.encodePacked(\\n                type(Manager).creationCode,\\n                abi.encode(uniswapInteraction, poolManager, mailBox, igp)\\n            )\\n        );\\n        bytes32 hash = keccak256(\\n            abi.encodePacked(bytes1(0xff), address(this), salt, bytecodeHash)\\n        );\\n        return address(uint160(uint256(hash)));\\n    }\\n}\\n\",\"keccak256\":\"0x1976caacf9837a321159acc3e02061b7803b4fb58921577dfd858a1503c31289\",\"license\":\"MIT\"},\"contracts/Hyperlane/IInterchainGasPayMaster.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.11;\\n\\n/**\\n * @title IInterchainGasPaymaster\\n * @notice Manages payments on a source chain to cover gas costs of relaying\\n * messages to destination chains.\\n */\\ninterface IInterchainGasPaymaster {\\n    /**\\n     * @notice Emitted when a payment is made for a message's gas costs.\\n     * @param messageId The ID of the message to pay for.\\n     * @param gasAmount The amount of destination gas paid for.\\n     * @param payment The amount of native tokens paid.\\n     */\\n    event GasPayment(\\n        bytes32 indexed messageId,\\n        uint256 gasAmount,\\n        uint256 payment\\n    );\\n\\n    function payForGas(\\n        bytes32 _messageId,\\n        uint32 _destinationDomain,\\n        uint256 _gasAmount,\\n        address _refundAddress\\n    ) external payable;\\n\\n    function quoteGasPayment(\\n        uint32 _destinationDomain,\\n        uint256 _gasAmount\\n    ) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xea5705377bcae5ff9dee6599d66f88c7e76a61169c2046a5efedcf4034354045\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/Hyperlane/IMailbox.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.8.0;\\n\\nimport {IInterchainSecurityModule} from \\\"../ISM/IInterchainSecurityModule.sol\\\";\\n\\ninterface IMailbox {\\n    // ============ Events ============\\n    /**\\n     * @notice Emitted when a new message is dispatched via Hyperlane\\n     * @param sender The address that dispatched the message\\n     * @param destination The destination domain of the message\\n     * @param recipient The message recipient address on `destination`\\n     * @param message Raw bytes of message\\n     */\\n    event Dispatch(\\n        address indexed sender,\\n        uint32 indexed destination,\\n        bytes32 indexed recipient,\\n        bytes message\\n    );\\n\\n    /**\\n     * @notice Emitted when a new message is dispatched via Hyperlane\\n     * @param messageId The unique message identifier\\n     */\\n    event DispatchId(bytes32 indexed messageId);\\n\\n    /**\\n     * @notice Emitted when a Hyperlane message is processed\\n     * @param messageId The unique message identifier\\n     */\\n    event ProcessId(bytes32 indexed messageId);\\n\\n    /**\\n     * @notice Emitted when a Hyperlane message is delivered\\n     * @param origin The origin domain of the message\\n     * @param sender The message sender address on `origin`\\n     * @param recipient The address that handled the message\\n     */\\n    event Process(\\n        uint32 indexed origin,\\n        bytes32 indexed sender,\\n        address indexed recipient\\n    );\\n\\n    function localDomain() external view returns (uint32);\\n\\n    function delivered(bytes32 messageId) external view returns (bool);\\n\\n    function defaultIsm() external view returns (IInterchainSecurityModule);\\n\\n    function dispatch(\\n        uint32 _destinationDomain,\\n        bytes32 _recipientAddress,\\n        bytes calldata _messageBody\\n    ) external returns (bytes32);\\n\\n    function process(\\n        bytes calldata _metadata,\\n        bytes calldata _message\\n    ) external;\\n\\n    function count() external view returns (uint32);\\n\\n    function root() external view returns (bytes32);\\n\\n    function latestCheckpoint() external view returns (bytes32, uint32);\\n\\n    function recipientIsm(\\n        address _recipient\\n    ) external view returns (IInterchainSecurityModule);\\n}\\n\",\"keccak256\":\"0x90d0ab3b41eafd1d385be94005e7adb2e92457e3383c33afa7aee95368786d82\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/ISM/IEmptyIsm.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.11;\\nimport \\\"./IInterchainSecurityModule.sol\\\";\\n\\ncontract EmptyIsm is IInterchainSecurityModule {\\n    //https://docs.uma.xyz/developers/quick-start\\n    /**\\n     * @notice Returns an enum that represents the type of security model\\n     * encoded by this ISM.\\n     * @dev Relayers infer how to fetch and format metadata.\\n     */\\n    function moduleType() external view returns (uint8) {\\n        return 6;\\n    }\\n\\n    function verify(\\n        bytes calldata _metadata,\\n        bytes calldata _message\\n    ) external returns (bool) {\\n        return true;\\n    }\\n}\\n\",\"keccak256\":\"0x334457aac7bfedca052cd001f65c2e8c07fb20d4c5d6ffd226b4841f24b55577\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/ISM/IInterchainSecurityModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.11;\\n\\ninterface IInterchainSecurityModule {\\n    /**\\n     * @notice Returns an enum that represents the type of security model\\n     * encoded by this ISM.\\n     * @dev Relayers infer how to fetch and format metadata.\\n     */\\n    function moduleType() external view returns (uint8);\\n\\n    /**\\n     * @notice Defines a security model responsible for verifying interchain\\n     * messages based on the provided metadata.\\n     * @param _metadata Off-chain metadata provided by a relayer, specific to\\n     * the security model encoded by the module (e.g. validator signatures)\\n     * @param _message Hyperlane encoded interchain message\\n     * @return True if the message was verified\\n     */\\n    function verify(\\n        bytes calldata _metadata,\\n        bytes calldata _message\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0xb9662352b2d1ce49d5e06177c8f839ebd0b40408c189e80b1f90c5fcdd85a8ee\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/ISM/IMultisigISM.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.0;\\n\\nimport {IInterchainSecurityModule} from \\\"./IInterchainSecurityModule.sol\\\";\\n\\ninterface IMultisigIsm is IInterchainSecurityModule {\\n    /**\\n     * @notice Returns the set of validators responsible for verifying _message\\n     * and the number of signatures required\\n     * @dev Can change based on the content of _message\\n     * @param _message Hyperlane formatted interchain message\\n     * @return validators The array of validator addresses\\n     * @return threshold The number of validator signatures needed\\n     */\\n    function validatorsAndThreshold(\\n        bytes calldata _message\\n    ) external view returns (address[] memory validators, uint8 threshold);\\n}\\n\",\"keccak256\":\"0x0798ce84bcee4aef53d1708c830fae81f711991fa1083aafcddc0b893acb97d1\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/IUniswapInteract.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\n// make sure to update latest 'main' branch on Uniswap repository\\nimport {IPoolManager, BalanceDelta} from \\\"@uniswap/v4-core/contracts/PoolManager.sol\\\";\\nimport {Currency, CurrencyLibrary} from \\\"@uniswap/v4-core/contracts/types/Currency.sol\\\";\\nimport {PoolKey, PoolId} from \\\"@uniswap/v4-core/contracts/types/PoolId.sol\\\";\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@uniswap/v4-core/contracts/types/PoolId.sol\\\";\\nimport \\\"@uniswap/v3-core/contracts/libraries/TickMath.sol\\\";\\nimport \\\"@uniswap/v3-periphery/contracts/libraries/LiquidityAmounts.sol\\\";\\nerror SwapExpired();\\nerror OnlyPoolManager();\\n\\nusing SafeERC20 for IERC20;\\nimport \\\"hardhat/console.sol\\\";\\n\\ncontract UniswapInteract {\\n    using CurrencyLibrary for Currency;\\n    IPoolManager public poolManager;\\n    mapping(uint256 => uint256) actionChoice;\\n    mapping(uint256 => IPoolManager.ModifyPositionParams) modificaitons;\\n    mapping(uint256 => uint256[2]) tickBounds;\\n    mapping(uint256 => IPoolManager.SwapParams) swaps;\\n    mapping(uint256 => uint256[2]) donations;\\n    struct position {\\n        int24 lowerBound;\\n        int24 upperBound;\\n        PoolId poolID;\\n    }\\n    mapping(address => position[]) positions;\\n\\n    uint256 modCounter;\\n    uint256 modSwap;\\n    uint256 doCount;\\n\\n    constructor(IPoolManager _poolManager) {\\n        poolManager = _poolManager;\\n    }\\n\\n    function getID(PoolKey memory poolKey) public pure returns (PoolId) {\\n        return PoolIdLibrary.toId(poolKey);\\n    }\\n\\n    function addLiquidity(\\n        PoolKey calldata poolKey,\\n        IPoolManager.ModifyPositionParams calldata modifyLiquidtyParams,\\n        uint256 deadline\\n    ) public payable returns (uint256, uint256) {\\n        modificaitons[modCounter] = modifyLiquidtyParams;\\n        positions[msg.sender].push(\\n            position(\\n                modifyLiquidtyParams.tickLower,\\n                modifyLiquidtyParams.tickUpper,\\n                getID(poolKey)\\n            )\\n        );\\n        bytes memory res = poolManager.lock(\\n            abi.encode(msg.sender, poolKey, 0, modCounter, deadline)\\n        );\\n\\n        return abi.decode(res, (uint256, uint256));\\n    }\\n\\n    function closePosition(\\n        PoolKey calldata poolKey,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint256 deadline\\n    ) public payable returns (int128, int128) {\\n        uint128 liq = poolManager.getLiquidity(\\n            PoolIdLibrary.toId(poolKey),\\n            address(this),\\n            tickLower,\\n            tickUpper\\n        );\\n        console.log(liq);\\n        modificaitons[modCounter] = IPoolManager.ModifyPositionParams(\\n            tickLower,\\n            tickUpper,\\n            -int128(liq)\\n        );\\n        bytes memory res = poolManager.lock(\\n            abi.encode(msg.sender, poolKey, 0, modCounter, deadline)\\n        );\\n        (int128 t0, int128 t1) = abi.decode(res, (int128, int128));\\n        //console.log(t0, t1);\\n        return (t0, t1);\\n    }\\n\\n    function donate(\\n        PoolKey calldata poolKey,\\n        uint256 amount0,\\n        uint256 amount1,\\n        uint256 deadline\\n    ) public payable returns (uint256, uint256) {\\n        donations[doCount] = [amount0, amount1];\\n        bytes memory res = poolManager.lock(\\n            abi.encode(msg.sender, poolKey, 2, doCount, deadline)\\n        );\\n\\n        return abi.decode(res, (uint256, uint256));\\n    }\\n\\n    function swap(\\n        PoolKey calldata poolKey,\\n        IPoolManager.SwapParams calldata swapParams,\\n        uint256 deadline\\n    ) public payable returns (int256, int256) {\\n        swaps[modSwap] = swapParams;\\n        bytes memory res = poolManager.lock(\\n            abi.encode(msg.sender, poolKey, 1, modSwap, deadline)\\n        );\\n\\n        return abi.decode(res, (int256, int256));\\n    }\\n\\n    function lockAcquired(\\n        bytes calldata data\\n    ) external returns (bytes memory res) {\\n        if (msg.sender != address(poolManager)) {\\n            revert OnlyPoolManager();\\n        }\\n\\n        (\\n            address user,\\n            PoolKey memory poolKey,\\n            uint256 action,\\n            uint256 counter,\\n            uint256 deadline\\n        ) = abi.decode(data, (address, PoolKey, uint256, uint256, uint256));\\n\\n        if (block.timestamp > deadline) {\\n            revert();\\n        }\\n        BalanceDelta delta;\\n        if (action == 0) {\\n            delta = poolManager.modifyPosition(\\n                poolKey,\\n                modificaitons[counter],\\n                \\\"0x\\\"\\n            );\\n            modCounter++;\\n        }\\n        if (action == 1) {\\n            delta = poolManager.swap(poolKey, swaps[counter], \\\"0x\\\");\\n            modSwap++;\\n        }\\n        if (action == 2) {\\n            delta = poolManager.donate(\\n                poolKey,\\n                donations[counter][0],\\n                donations[counter][1],\\n                \\\"0x\\\"\\n            );\\n            doCount++;\\n        }\\n        _settleCurrencyBalance(poolKey.currency0, delta.amount0());\\n        _settleCurrencyBalance(poolKey.currency1, delta.amount1());\\n        if (action != 2) {\\n            IERC20(Currency.unwrap(poolKey.currency0)).safeTransfer(\\n                user,\\n                IERC20(Currency.unwrap(poolKey.currency0)).balanceOf(\\n                    (address(this))\\n                )\\n            );\\n\\n            IERC20(Currency.unwrap(poolKey.currency1)).safeTransfer(\\n                user,\\n                IERC20(Currency.unwrap(poolKey.currency1)).balanceOf(\\n                    (address(this))\\n                )\\n            );\\n        }\\n\\n        res = abi.encode(delta.amount0(), delta.amount1());\\n        //return new bytes();\\n    }\\n\\n    function _settleCurrencyBalance(\\n        Currency currency,\\n        int128 deltaAmount\\n    ) private {\\n        if (deltaAmount < 0) {\\n            console.log(\\\"Amount:\\\", uint128(-deltaAmount));\\n            poolManager.take(currency, address(this), uint128(-deltaAmount));\\n            return;\\n        }\\n\\n        if (currency.isNative()) {\\n            poolManager.settle{value: uint128(deltaAmount)}(currency);\\n            return;\\n        }\\n\\n        IERC20(Currency.unwrap(currency)).safeTransfer(\\n            address(poolManager),\\n            uint128(deltaAmount)\\n        );\\n        poolManager.settle(currency);\\n    }\\n\\n    function getLiquidityAmount(\\n        int24 currentTick,\\n        int24 lowerTick,\\n        int24 upperTick,\\n        uint256 amount0,\\n        uint256 amount1\\n    ) external pure returns (uint128) {\\n        return\\n            LiquidityAmounts.getLiquidityForAmounts(\\n                TickMath.getSqrtRatioAtTick(currentTick),\\n                TickMath.getSqrtRatioAtTick(lowerTick),\\n                TickMath.getSqrtRatioAtTick(upperTick),\\n                amount0,\\n                amount1\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x1d5cc55b7f91e46b54489e0c6cdaa19c867798a47d87eb90ccdeebb9fee3aab2\",\"license\":\"MIT\"},\"contracts/Manager.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\nimport \\\"@uniswap/v4-core/contracts/interfaces/IPoolManager.sol\\\";\\nimport \\\"./Proxy.sol\\\";\\nimport {PoolKey} from \\\"@uniswap/v4-core/contracts/types/PoolId.sol\\\";\\nimport {IPoolManager} from \\\"@uniswap/v4-core/contracts/PoolManager.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\nimport {Currency, CurrencyLibrary} from \\\"@uniswap/v4-core/contracts/types/Currency.sol\\\";\\n\\nimport \\\"./Hyperlane/IMailbox.sol\\\";\\nimport \\\"./Hyperlane/IInterchainGasPayMaster.sol\\\";\\nimport \\\"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\\\";\\nimport \\\"./ISM/IEmptyIsm.sol\\\";\\nimport \\\"./ISM/IMultisigISM.sol\\\";\\nimport \\\"./IUniswapInteract.sol\\\";\\nimport \\\"./Hooks/Utils/BaseHook.sol\\\";\\n\\ncontract Manager is BaseHook {\\n    //Hook Stuff\\n    uint32 deployTimestamp;\\n    uint256 public counterBeforeSwap;\\n    uint256 public counterBeforeInit;\\n    uint256 public counterAfterSwap;\\n\\n    //Uniswap Trade Stuff\\n    UniswapInteract public immutable uniswapInteract;\\n    // IPoolManager public immutable override poolManager;\\n    Proxy public proxyToken;\\n    address public proxyAddy;\\n    //PoolKey public poolKey;\\n    mapping(address => PoolKey) public tokenToKey;\\n\\n    mapping(address => bool) public approvedToken;\\n\\n    uint256 public count;\\n\\n    //Hyperlane Stuff:\\n    mapping(uint256 => address) public domainToAddress; //Domain to Manager address\\n    IMailbox public immutable mailBox;\\n    IInterchainGasPaymaster public immutable igp;\\n    address public ism;\\n    uint32 domain = 0;\\n\\n    constructor(\\n        address _uI,\\n        address _poolManager,\\n        address _mailBox,\\n        address _igp\\n    ) BaseHook(IPoolManager(_poolManager)) {\\n        uniswapInteract = UniswapInteract(_uI);\\n        // poolManager = IPoolManager(_poolManager);\\n        mailBox = IMailbox(_mailBox);\\n        igp = IInterchainGasPaymaster(_igp);\\n    }\\n\\n    function setProxyToken(address _proxyToken) public {\\n        proxyToken = Proxy(_proxyToken);\\n        proxyAddy = _proxyToken;\\n    }\\n\\n    function setISM(address _newISM) public {\\n        ism = _newISM;\\n    }\\n\\n    function addDomain(uint256 domain, address managerAddress) public {\\n        domainToAddress[domain] = managerAddress;\\n    }\\n\\n    function initializeProxyPool(\\n        address otherToken,\\n        uint160 sqrtPRice,\\n        bytes memory hookData\\n    ) public {\\n        PoolKey memory myKey;\\n\\n        if (otherToken < proxyAddy) {\\n            myKey = PoolKey(\\n                Currency.wrap(otherToken),\\n                Currency.wrap(proxyAddy),\\n                3000,\\n                60,\\n                IHooks(0x0000000000000000000000000000000000000000)\\n            );\\n        } else {\\n            myKey = PoolKey(\\n                Currency.wrap(proxyAddy),\\n                Currency.wrap(otherToken),\\n                3000,\\n                60,\\n                IHooks(address(this))\\n            );\\n        }\\n        poolManager.initialize(myKey, sqrtPRice, hookData);\\n        tokenToKey[otherToken] = myKey;\\n    }\\n\\n    function createPosition(\\n        address token,\\n        uint256 tokenAmount,\\n        int24 lower,\\n        int24 upper\\n    ) public {\\n        TransferHelper.safeTransferFrom(\\n            token,\\n            msg.sender,\\n            address(this),\\n            tokenAmount\\n        );\\n        uint128 liquidity = 0;\\n        uint160 sqrtA = TickMath.getSqrtRatioAtTick(lower);\\n        uint160 sqrtB = TickMath.getSqrtRatioAtTick(upper);\\n        if (token < proxyAddy) {\\n            //token is 0\\n            liquidity = LiquidityAmounts.getLiquidityForAmount0(\\n                sqrtA,\\n                sqrtB,\\n                tokenAmount\\n            );\\n        } else {\\n            liquidity = LiquidityAmounts.getLiquidityForAmount1(\\n                sqrtA,\\n                sqrtB,\\n                tokenAmount\\n            );\\n        }\\n        //uniswapInteract\\n        uint256 bigAmount = 1000000000000000000000000000;\\n        proxyToken.mint(bigAmount);\\n        TransferHelper.safeTransfer(\\n            proxyAddy,\\n            address(uniswapInteract),\\n            bigAmount\\n        );\\n        TransferHelper.safeTransfer(\\n            (token),\\n            address(uniswapInteract),\\n            tokenAmount\\n        );\\n        (uint256 t0Amount, uint256 t1Amount) = uniswapInteract.addLiquidity(\\n            tokenToKey[token],\\n            IPoolManager.ModifyPositionParams(lower, upper, int128(liquidity)),\\n            block.timestamp + 10000000\\n        );\\n        if (token < proxyAddy) {\\n            //token is 0\\n            TransferHelper.safeTransfer(address(token), msg.sender, t0Amount);\\n            proxyToken.burn(bigAmount - t1Amount);\\n        } else {\\n            //token is 1\\n            TransferHelper.safeTransfer(address(token), msg.sender, t1Amount);\\n            proxyToken.burn(bigAmount - t0Amount);\\n        }\\n    }\\n\\n    function closePosition(\\n        address token,\\n        int24 lower,\\n        int24 upper\\n    ) public returns (uint256) {\\n        (int128 t0Amount, int128 t1Amount) = uniswapInteract.closePosition(\\n            tokenToKey[token],\\n            lower,\\n            upper,\\n            block.timestamp + 100000000\\n        );\\n        if (token < proxyAddy) {\\n            //token is 0\\n            //transfer to user??\\n            TransferHelper.safeTransfer(\\n                address(Currency.unwrap(tokenToKey[token].currency0)),\\n                msg.sender,\\n                uint128(-t0Amount)\\n            );\\n            proxyToken.burn(uint128(-t1Amount));\\n            console.log(\\\"Earend:\\\", uint128(-t1Amount));\\n            return uint128(-t0Amount);\\n        } else {\\n            TransferHelper.safeTransfer(\\n                address(Currency.unwrap(tokenToKey[token].currency1)),\\n                msg.sender,\\n                uint128(-t1Amount)\\n            );\\n            console.log(\\\"Earend:\\\", uint128(-t0Amount));\\n\\n            proxyToken.burn(uint128(-t0Amount));\\n            return uint128(-t1Amount);\\n        }\\n    }\\n\\n    //zeroForOne - true - 4295128740\\n    //zeroForOne - false - 1461446703485210103287273052203988822378723970342\\n    function swap(address token, bool toProxy, uint256 tokenAmount) public {\\n        TransferHelper.safeTransferFrom(\\n            token,\\n            msg.sender,\\n            address(this),\\n            tokenAmount\\n        );\\n        //uniswapInteract\\n        bool zeroForOne;\\n        if (token < proxyAddy) {\\n            //token is 0\\n            zeroForOne = true;\\n            zeroForOne == toProxy ? true : false;\\n        } else {\\n            zeroForOne = false;\\n            zeroForOne == toProxy ? false : true;\\n        }\\n        TransferHelper.safeTransfer(\\n            token,\\n            address(uniswapInteract),\\n            tokenAmount\\n        );\\n        uint256 balBeforeProxy = IERC20(proxyAddy).balanceOf(address(this));\\n        uint256 balBeforeToken = IERC20(token).balanceOf(address(this));\\n\\n        uniswapInteract.swap(\\n            tokenToKey[token],\\n            IPoolManager.SwapParams(\\n                zeroForOne,\\n                int256(tokenAmount),\\n                zeroForOne\\n                    ? 4295128740\\n                    : 1461446703485210103287273052203988822378723970341\\n            ),\\n            block.timestamp + 10000000\\n        );\\n        if (balBeforeToken < IERC20(token).balanceOf(address(this))) {\\n            TransferHelper.safeTransfer(\\n                token,\\n                msg.sender,\\n                IERC20(token).balanceOf(address(this)) - balBeforeToken\\n            );\\n        }\\n        if (balBeforeProxy < IERC20(proxyAddy).balanceOf(address(this))) {\\n            TransferHelper.safeTransfer(\\n                proxyAddy,\\n                msg.sender,\\n                IERC20(proxyAddy).balanceOf(address(this)) - balBeforeProxy\\n            );\\n        }\\n    }\\n\\n    function swapToOtherChain(\\n        address token,\\n        uint256 tokenAmount,\\n        uint32 domainGoal,\\n        address endingAsset,\\n        address endingAddress\\n    ) public payable {\\n        TransferHelper.safeTransferFrom(\\n            token,\\n            msg.sender,\\n            address(this),\\n            tokenAmount\\n        );\\n        bool zeroForOne;\\n        bool toProxy = true;\\n        if (token < proxyAddy) {\\n            //token is 0\\n            zeroForOne = true;\\n            zeroForOne == toProxy ? true : false;\\n        } else {\\n            zeroForOne = false;\\n            zeroForOne == toProxy ? false : true;\\n        }\\n        TransferHelper.safeTransfer(\\n            token,\\n            address(uniswapInteract),\\n            tokenAmount\\n        );\\n        (int256 t0, int256 t1) = uniswapInteract.swap(\\n            tokenToKey[token],\\n            IPoolManager.SwapParams(\\n                zeroForOne,\\n                int256(tokenAmount),\\n                zeroForOne\\n                    ? 4295128740\\n                    : 1461446703485210103287273052203988822378723970341\\n            ),\\n            block.timestamp + 10000000\\n        );\\n        console.log(uint256(-t0), uint256(t1));\\n        //Now transfer the amount of proxy tokens that they just earend\\n        if (toProxy) {\\n            //token is 0\\n            if (zeroForOne) {\\n                proxyAmount = uint256(-t1);\\n            } else {\\n                proxyAmount = uint256(-t0);\\n            }\\n        }\\n        //proxyToken.burn(proxyAmount);\\n        bytes32 _messageId = mailBox.dispatch(\\n            domainGoal,\\n            addressToBytes32(domainToAddress[domainGoal]),\\n            abi.encode(\\n                abi.encode(proxyAmount, endingAsset, endingAddress),\\n                0,\\n                msg.sender\\n            )\\n        );\\n\\n        //Pay from the contract's balance\\n        igp.payForGas{value: msg.value}(\\n            _messageId, // The ID of the message that was just dispatched\\n            domainGoal, // The destination domain of the message\\n            200000,\\n            address(this) // refunds are returned to this contract\\n        );\\n    }\\n\\n    uint256 public proxyAmount;\\n\\n    function handle(\\n        uint32 _origin,\\n        bytes32 _sender,\\n        bytes calldata _body\\n    ) external {\\n        count++;\\n        //Decompose the data\\n        bool toProxy = false;\\n        (bytes memory data, uint8 action, address user) = abi.decode(\\n            _body,\\n            (bytes, uint8, address)\\n        );\\n        if (action == 0) {\\n            (\\n                uint256 _proxyAmount,\\n                address desiredAsset,\\n                address endingAddress\\n            ) = abi.decode(data, (uint256, address, address));\\n            if (action == 0) {\\n                //address token, bool toProxy, uint256 tokenAmount\\n                proxyToken.mint(_proxyAmount);\\n                uint256 balBefore = IERC20(desiredAsset).balanceOf(\\n                    address(this)\\n                );\\n                //         uint256 balBeforeToken = IERC20(desiredAsset).balanceOf(\\n                //             address(this)\\n                //         );\\n                //uniswapInteract\\n                bool zeroForOne;\\n                if (desiredAsset < proxyAddy) {\\n                    //token is 0\\n                    zeroForOne = false;\\n                } else {\\n                    zeroForOne = true;\\n                }\\n                TransferHelper.safeTransfer(\\n                    proxyAddy,\\n                    address(uniswapInteract),\\n                    _proxyAmount\\n                );\\n\\n                uniswapInteract.swap(\\n                    tokenToKey[desiredAsset],\\n                    IPoolManager.SwapParams(\\n                        zeroForOne,\\n                        int256(_proxyAmount),\\n                        zeroForOne\\n                            ? 4295128740\\n                            : 1461446703485210103287273052203988822378723970341\\n                    ),\\n                    block.timestamp + 10000000\\n                );\\n\\n                uint256 balAfter = IERC20(desiredAsset).balanceOf(\\n                    address(this)\\n                );\\n                if (balAfter > balBefore) {\\n                    TransferHelper.safeTransfer(\\n                        desiredAsset,\\n                        endingAddress,\\n                        balAfter - balBefore\\n                    );\\n                }\\n            }\\n        }\\n        if (action == 1) {\\n            (uint256 boostPerSwap, uint256 totalAmount) = abi.decode(\\n                data,\\n                (uint256, uint256)\\n            );\\n            totalBoostPerSwapDomain[domain] += totalAmount;\\n            boostPerSwapDomain[domain] += boostPerSwap;\\n        }\\n    }\\n\\n    // function handle(\\n    //     uint256 _proxyAmount,\\n    //     address desiredAsset,\\n    //     address endingAddress,\\n    //     uint8 action\\n    // ) external {\\n    //     count++;\\n    //     //Decompose the data\\n\\n    //     if (action == 0) {\\n    //         //address token, bool toProxy, uint256 tokenAmount\\n    //         proxyToken.mint(_proxyAmount);\\n    //         uint256 balBefore = IERC20(desiredAsset).balanceOf(address(this));\\n    //         //         uint256 balBeforeToken = IERC20(desiredAsset).balanceOf(\\n    //         //             address(this)\\n    //         //         );\\n    //         swap(desiredAsset, false, _proxyAmount);\\n\\n    //         uint256 balAfter = IERC20(desiredAsset).balanceOf(address(this));\\n    //         if (balAfter > balBefore) {\\n    //             TransferHelper.safeTransfer(\\n    //                 desiredAsset,\\n    //                 endingAddress,\\n    //                 balAfter - balBefore\\n    //             );\\n    //         }\\n    //     }\\n    // }\\n\\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\\n        return bytes32(uint256(uint160(_addr)));\\n    }\\n\\n    function poke(uint32 domain) public payable {\\n        uint256 gasAmount = 100000;\\n        bytes32 _messageId = mailBox.dispatch(\\n            domain,\\n            addressToBytes32(domainToAddress[domain]),\\n            abi.encode(msg.sender)\\n            //abi.encode(message)\\n        );\\n\\n        // Pay from the contract's balance\\n        igp.payForGas{value: msg.value}(\\n            _messageId, // The ID of the message that was just dispatched\\n            domain, // The destination domain of the message\\n            gasAmount,\\n            address(this) // refunds are returned to this contract\\n        );\\n    }\\n\\n    function interchainSecurityModule() external view returns (address) {\\n        return ism;\\n    }\\n\\n    function getFee(\\n        address,\\n        PoolKey calldata,\\n        IPoolManager.SwapParams calldata,\\n        bytes calldata\\n    ) external view returns (uint24) {\\n        uint24 startingFee = 3000;\\n        uint32 lapsed = _blockTimestamp() - deployTimestamp;\\n        return startingFee + (uint24(lapsed) * 100) / 60; // 100 bps a minute\\n    }\\n\\n    struct boostInfo {\\n        uint256 swapCount;\\n        uint256 boostID;\\n        uint256 boostPerSwap;\\n        address owner;\\n    }\\n    uint256 boostID;\\n    mapping(uint256 => boostInfo) public idToInfo;\\n    mapping(uint32 => uint256) public totalBoostPerSwapDomain;\\n    mapping(address => uint256) public totalBoostPerSwapToken;\\n    mapping(uint32 => uint256) public boostPerSwapDomain;\\n    mapping(address => uint256) public boostPerSwapToken;\\n\\n    function createBoost(\\n        uint256 swapCount,\\n        uint256 boostPerSwap,\\n        address[] memory approvedTokens,\\n        uint32[] memory approvedDomains\\n    ) public {\\n        console.log(\\\"AMount:\\\", swapCount * boostPerSwap);\\n        TransferHelper.safeTransferFrom(\\n            proxyAddy,\\n            msg.sender,\\n            address(this),\\n            swapCount * boostPerSwap\\n        );\\n\\n        idToInfo[boostID] = boostInfo(\\n            swapCount,\\n            boostID,\\n            boostPerSwap,\\n            msg.sender\\n        );\\n        for (uint i = 0; i < approvedTokens.length; i++) {\\n            boostPerSwapToken[approvedTokens[i]] += boostPerSwap;\\n\\n            totalBoostPerSwapToken[approvedTokens[i]] +=\\n                boostPerSwap *\\n                swapCount;\\n        }\\n    }\\n\\n    function createBoostDomain(\\n        uint256 swapCount,\\n        uint256 boostPerSwap,\\n        uint32[] memory approvedDomains\\n    ) public {\\n        TransferHelper.safeTransferFrom(\\n            proxyAddy,\\n            msg.sender,\\n            address(this),\\n            swapCount * boostPerSwap\\n        );\\n\\n        idToInfo[boostID] = boostInfo(\\n            swapCount,\\n            boostID,\\n            boostPerSwap,\\n            msg.sender\\n        );\\n        for (uint i = 0; i < approvedDomains.length; i++) {\\n            bytes32 _messageId = mailBox.dispatch(\\n                approvedDomains[i],\\n                addressToBytes32(domainToAddress[approvedDomains[i]]),\\n                abi.encode(\\n                    abi.encode(boostPerSwap, boostPerSwap * swapCount),\\n                    1,\\n                    msg.sender\\n                )\\n            );\\n\\n            // Pay from the contract's balance\\n            igp.payForGas{value: 2000000000000000}(\\n                _messageId, // The ID of the message that was just dispatched\\n                approvedDomains[i], // The destination domain of the message\\n                100000,\\n                address(this) // refunds are returned to this contract\\n            );\\n        }\\n    }\\n\\n    function beforeSwap(\\n        address sender,\\n        PoolKey calldata key,\\n        IPoolManager.SwapParams calldata params,\\n        bytes calldata hookData\\n    ) external override returns (bytes4) {\\n        console.log(\\\"Before Swap\\\");\\n        counterBeforeSwap++;\\n        address token = Currency.unwrap(key.currency0) == proxyAddy\\n            ? Currency.unwrap(key.currency1)\\n            : Currency.unwrap(key.currency0);\\n\\n        uint256 boost = boostPerSwapToken[token] + boostPerSwapDomain[domain];\\n        console.log(boost, \\\"is boost amount\\\");\\n        TransferHelper.safeTransfer(proxyAddy, address(uniswapInteract), boost);\\n        if (\\n            boost >\\n            totalBoostPerSwapToken[token] + totalBoostPerSwapDomain[domain]\\n        ) {\\n            return this.beforeSwap.selector;\\n        }\\n        if (boost > 0) {\\n            if (token < proxyAddy) {\\n                uniswapInteract.donate(\\n                    tokenToKey[token],\\n                    0,\\n                    boost,\\n                    block.timestamp + 100000000\\n                );\\n            } else {\\n                console.log(IERC20(token).balanceOf(address(uniswapInteract)));\\n                uniswapInteract.donate(\\n                    tokenToKey[token],\\n                    boost,\\n                    0,\\n                    block.timestamp + 10000000\\n                );\\n                console.log(IERC20(token).balanceOf(address(uniswapInteract)));\\n\\n                console.log(\\\"Fin\\\");\\n            }\\n        }\\n\\n        totalBoostPerSwapToken[token] -= boostPerSwapToken[token];\\n        // totalBoostPerSwapDomain[domain] -= totalBoostPerSwapDomain[domain];\\n\\n        return this.beforeSwap.selector;\\n    }\\n\\n    function afterSwap(\\n        address sender,\\n        PoolKey calldata key,\\n        IPoolManager.SwapParams calldata params,\\n        BalanceDelta delta,\\n        bytes calldata hookData\\n    ) external override returns (bytes4) {\\n        counterAfterSwap++;\\n        // (uint32 domainGoal, address targetAddy, uint256 _proxyAmount) = abi\\n        //     .decode(hookData, (uint32, address, uint256));\\n        // bytes32 _messageId = mailBox.dispatch(\\n        //     domainGoal,\\n        //     addressToBytes32(targetAddy),\\n        //     abi.encode(abi.encode(_proxyAmount), sender)\\n        //     //abi.encode(message)\\n        // );\\n\\n        // // Pay from the contract's balance\\n        // igp.payForGas{value: 2000000000000000}(\\n        //     _messageId, // The ID of the message that was just dispatched\\n        //     domain, // The destination domain of the message\\n        //     100000,\\n        //     address(this) // refunds are returned to this contract\\n        // );\\n\\n        //I could execute this after a swap, and it would check the direction\\n\\n        return this.afterSwap.selector;\\n    }\\n\\n    //function getTokenPrice() view returns () {}\\n    //Fancy way to get tokenPriec\\n\\n    function beforeInitialize(\\n        address sender,\\n        PoolKey calldata key,\\n        uint160 sqrtPriceX96,\\n        bytes calldata hookData\\n    ) external override returns (bytes4) {\\n        counterBeforeInit++;\\n        require(sender == address(this));\\n        //require(sqrtPriceX96 == )\\n\\n        return this.beforeInitialize.selector;\\n    }\\n\\n    /// @dev For mocking\\n    function _blockTimestamp() internal view virtual returns (uint32) {\\n        return uint32(block.timestamp);\\n    }\\n\\n    function getHooksCalls() public pure override returns (Hooks.Calls memory) {\\n        return\\n            Hooks.Calls({\\n                beforeInitialize: true,\\n                afterInitialize: false,\\n                beforeModifyPosition: false,\\n                afterModifyPosition: false,\\n                beforeSwap: true,\\n                afterSwap: true,\\n                beforeDonate: false,\\n                afterDonate: false\\n            });\\n    }\\n\\n    receive() external payable {}\\n}\\n\",\"keccak256\":\"0x59aca7bbd89997d0221339febad1f53ee40b02038747521ce17eb95eb1671343\",\"license\":\"UNLICENSED\"},\"contracts/Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: UNLISCENSED\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\ncontract Proxy is ERC20 {\\n    address immutable manager;\\n\\n    constructor(address _manager) ERC20(\\\"PROXY\\\", \\\"PRX\\\") {\\n        manager = _manager;\\n    }\\n\\n    function mint(uint256 amount) public {\\n        require(msg.sender == manager);\\n\\n        _mint(manager, amount);\\n    }\\n\\n    function burn(uint256 amount) public {\\n        require(msg.sender == manager);\\n        _burn(manager, amount);\\n    }\\n}\\n\",\"keccak256\":\"0xb29b39720b07b2a1e8b83fc261af2883cf8678e79f0a35ded9a9418a047afa1e\",\"license\":\"UNLISCENSED\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS =\\n        0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    consoleAddress,\\n                    add(payload, 32),\\n                    mload(payload),\\n                    0,\\n                    0\\n                )\\n            )\\n        }\\n    }\\n\\n    function _castToPure(\\n      function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castToPure(_sendLogPayloadImplementation)(payload);\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\\n\",\"keccak256\":\"0x7434453e6d3b7d0e5d0eb7846ffdbc27f0ccf3b163591263739b628074dc103a\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50614976806100206000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063864c17d714610046578063c4ceb78914610075578063f84b2a3f1461008a575b600080fd5b6100596100543660046102b3565b61009d565b6040516001600160a01b03909116815260200160405180910390f35b6100886100833660046102e8565b6100c7565b005b610059610098366004610344565b610174565b600081815481106100ad57600080fd5b6000918252602090912001546001600160a01b0316905081565b6100fa604051806040016040528060128152602001713232b83637bcb4b733903437b7b5b997171760711b81525061023b565b6000818686868660405161010d906102a6565b61011a94939291906103b1565b8190604051809103906000f590508015801561013a573d6000803e3d6000fd5b5081546001810183556000928352602090922090910180546001600160a01b0319166001600160a01b039092169190911790555050505050565b60008060405180602001610187906102a6565b601f1982820381018352601f9091011660408190526101b09089908990899089906020016103b1565b60408051601f19818403018152908290526101ce9291602001610400565b60408051601f1981840301815282825280516020918201206001600160f81b0319828501523060601b6001600160601b0319166021850152603584019690965260558084019690965281518084039096018652607590920190528351930192909220979650505050505050565b61027e8160405160240161024f919061042f565b60408051601f198184030181529190526020810180516001600160e01b031663104c13eb60e21b179052610281565b50565b61027e8160006a636f6e736f6c652e6c6f679050600080835160208501845afa505050565b6144de8061046383390190565b6000602082840312156102c557600080fd5b5035919050565b80356001600160a01b03811681146102e357600080fd5b919050565b600080600080600060a0868803121561030057600080fd5b610309866102cc565b9450610317602087016102cc565b9350610325604087016102cc565b9250610333606087016102cc565b949793965091946080013592915050565b60008060008060008060c0878903121561035d57600080fd5b610366876102cc565b9550610374602088016102cc565b9450610382604088016102cc565b9350610390606088016102cc565b925061039e608088016102cc565b915060a087013590509295509295509295565b6001600160a01b03948516815292841660208401529083166040830152909116606082015260800190565b60005b838110156103f75781810151838201526020016103df565b50506000910152565b600083516104128184602088016103dc565b8351908301906104268183602088016103dc565b01949350505050565b602081526000825180602084015261044e8160408501602087016103dc565b601f01601f1916919091016040019291505056fe610100604052600a805463ffffffff60a01b191690553480156200002257600080fd5b50604051620044de380380620044de83398101604081905262000045916200022c565b6001600160a01b038316608052826200005e3062000080565b506001600160a01b0393841660a05290831660c05290911660e0525062000289565b62000115816200010f6040805161010081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101919091525060408051610100810182526001808252600060208301819052928201839052606082018390526080820181905260a082015260c0810182905260e081019190915290565b62000118565b50565b805115156001609f1b83161515141580620001415750602081015115156001609e1b8316151514155b806200015b5750604081015115156001609d1b8316151514155b80620001755750606081015115156001609c1b8316151514155b806200018f5750608081015115156001609b1b8316151514155b80620001a9575060a081015115156001609a1b8316151514155b80620001c3575060c08101511515600160991b8316151514155b80620001dd575060e08101511515600160981b8316151514155b156200020b57604051630732d7b560e51b81526001600160a01b038316600482015260240160405180910390fd5b5050565b80516001600160a01b03811681146200022757600080fd5b919050565b600080600080608085870312156200024357600080fd5b6200024e856200020f565b93506200025e602086016200020f565b92506200026e604086016200020f565b91506200027e606086016200020f565b905092959194509250565b60805160a05160c05160e05161417a62000364600039600081816109a9015281816116c5015281816118d9015261280b015260008181610557015281816115ca0152818161182001526126c90152600081816105a101528181610a0701528181610cdf01528181610deb01528181611180015281816111ab015281816111d5015281816114360152818161146001528181611aca01528181611af101528181611e3f01528181611ef601528181611fbe01528181612047015261210a0152600081816108c4015281816121b00152612519015261417a6000f3fe6080604052600436106101fb5760003560e01c806306661abd146102075780630ac10973146102305780631087004a1461025057806312386029146102725780632492963b1461029f5780632794823f146102bf5780632ab7a3e2146102d25780632f1ec5e01461030657806330b7cdef1461031c5780633440d82014610355578063345f0ffa14610375578063346c609e146103885780634deefab2146103b55780634df87c09146103d55780634faaefae1461041557806356d5d47514610435578063575e24b414610455578063612c39b71461047557806369d7e873146105185780636bd5c4e61461054557806378e1abb5146105795780638a6e59461461058f57806391e834a5146105c357806395ae34ed146105f057806396e13e471461061d578063a184a2ce14610633578063a910f80f1461067c578063ab6291fe14610697578063b069f61f146106c4578063b09a078514610766578063b47b2fb114610786578063b6a8b0fa146107a6578063beecd2bd146107c1578063c94bacaa14610808578063d94a7e531461083e578063dc4c90d3146108b2578063de4a787f146108e6578063de523cf314610923578063dff78df714610941578063e1b4af69146107a6578063e8c55a6114610957578063ead0f5a714610977578063f28b2daa14610997578063fe9a6f45146109cb57600080fd5b3661020257005b600080fd5b34801561021357600080fd5b5061021d60085481565b6040519081526020015b60405180910390f35b34801561023c57600080fd5b5061021d61024b3660046132d7565b6109e6565b34801561025c57600080fd5b5061027061026b366004613330565b610c82565b005b34801561027e57600080fd5b50600554610292906001600160a01b031681565b6040516102279190613371565b3480156102ab57600080fd5b506102706102ba366004613385565b6110a4565b6102706102cd3660046133ec565b6113d4565b3480156102de57600080fd5b506102f26102ed3660046134c4565b611757565b60405162ffffff9091168152602001610227565b34801561031257600080fd5b5061021d60025481565b34801561032857600080fd5b5061033c61033736600461353f565b6117a2565b6040516001600160e01b03199091168152602001610227565b34801561036157600080fd5b5061033c6103703660046135c4565b6117bd565b610270610383366004613622565b6117fa565b34801561039457600080fd5b5061021d6103a336600461363d565b600f6020526000908152604090205481565b3480156103c157600080fd5b50600a54610292906001600160a01b031681565b3480156103e157600080fd5b506104056103f036600461363d565b60076020526000908152604090205460ff1681565b6040519015158152602001610227565b34801561042157600080fd5b50600454610292906001600160a01b031681565b34801561044157600080fd5b5061027061045036600461365a565b611961565b34801561046157600080fd5b5061033c6104703660046134c4565b611d26565b34801561048157600080fd5b5061050b6040805161010081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101919091525060408051610100810182526001808252600060208301819052928201839052606082018390526080820181905260a082015260c0810182905260e081019190915290565b60405161022791906136b3565b34801561052457600080fd5b5061021d61053336600461363d565b60116020526000908152604090205481565b34801561055157600080fd5b506102927f000000000000000000000000000000000000000000000000000000000000000081565b34801561058557600080fd5b5061021d600b5481565b34801561059b57600080fd5b506102927f000000000000000000000000000000000000000000000000000000000000000081565b3480156105cf57600080fd5b5061021d6105de366004613622565b600e6020526000908152604090205481565b3480156105fc57600080fd5b5061021d61060b366004613622565b60106020526000908152604090205481565b34801561062957600080fd5b5061021d60015481565b34801561063f57600080fd5b5061027061064e36600461373c565b60009182526009602052604090912080546001600160a01b0319166001600160a01b03909216919091179055565b34801561068857600080fd5b5061033c61033736600461376c565b3480156106a357600080fd5b506106b76106b23660046137dc565b6121a3565b604051610227919061386d565b3480156106d057600080fd5b506107266106df36600461363d565b6006602052600090815260409020805460018201546002928301546001600160a01b03928316938284169362ffffff600160a01b85041693600160b81b900490910b911685565b604080516001600160a01b039687168152948616602086015262ffffff9093169284019290925260020b606083015291909116608082015260a001610227565b34801561077257600080fd5b5061027061078136600461395b565b612291565b34801561079257600080fd5b5061033c6107a136600461353f565b61241f565b3480156107b257600080fd5b5061033c610337366004613a31565b3480156107cd57600080fd5b506102706107dc36600461363d565b600480546001600160a01b039092166001600160a01b0319928316811790915560058054909216179055565b34801561081457600080fd5b50610292610823366004613a8f565b6009602052600090815260409020546001600160a01b031681565b34801561084a57600080fd5b50610889610859366004613a8f565b600d602052600090815260409020805460018201546002830154600390930154919290916001600160a01b031684565b604080519485526020850193909352918301526001600160a01b03166060820152608001610227565b3480156108be57600080fd5b506102927f000000000000000000000000000000000000000000000000000000000000000081565b3480156108f257600080fd5b5061027061090136600461363d565b600a80546001600160a01b0319166001600160a01b0392909216919091179055565b34801561092f57600080fd5b50600a546001600160a01b0316610292565b34801561094d57600080fd5b5061021d60035481565b34801561096357600080fd5b50610270610972366004613b17565b612448565b34801561098357600080fd5b50610270610992366004613b78565b612637565b3480156109a357600080fd5b506102927f000000000000000000000000000000000000000000000000000000000000000081565b3480156109d757600080fd5b5061033c6103373660046134c4565b6001600160a01b0383811660009081526006602052604081209091829182917f00000000000000000000000000000000000000000000000000000000000000001690634ff490fb908787610a3e426305f5e100613bd3565b6040518563ffffffff1660e01b8152600401610a5d9493929190613c2b565b60408051808303816000875af1158015610a7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a9f9190613c6d565b60055491935091506001600160a01b039081169087161015610bb0576001600160a01b03808716600090815260066020526040902054610af2911633610ae485613ca0565b6001600160801b03166128cb565b6004546001600160a01b03166342966c68610b0c83613ca0565b6040518263ffffffff1660e01b8152600401610b289190613cc3565b600060405180830381600087803b158015610b4257600080fd5b505af1158015610b56573d6000803e3d6000fd5b50505050610b956040518060400160405280600781526020016622b0b932b7321d60c91b81525082610b8790613ca0565b6001600160801b03166129c9565b610b9e82613ca0565b6001600160801b031692505050610c7b565b6001600160a01b03808716600090815260066020526040902060010154610bdc911633610ae484613ca0565b610c096040518060400160405280600781526020016622b0b932b7321d60c91b81525083610b8790613ca0565b6004546001600160a01b03166342966c68610c2384613ca0565b6040518263ffffffff1660e01b8152600401610c3f9190613cc3565b600060405180830381600087803b158015610c5957600080fd5b505af1158015610c6d573d6000803e3d6000fd5b5050505080610b9e90613ca0565b9392505050565b610c8e83333084612a12565b6005546000906001600160a01b039081169085161015610cc4575060018215158114610cbb576000610cbe565b60015b50610cd9565b5060008215610cd4576001610cd7565b60005b505b610d04847f0000000000000000000000000000000000000000000000000000000000000000846128cb565b6005546040516370a0823160e01b81526000916001600160a01b0316906370a0823190610d35903090600401613371565b602060405180830381865afa158015610d52573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d769190613cd7565b90506000856001600160a01b03166370a08231306040518263ffffffff1660e01b8152600401610da69190613371565b602060405180830381865afa158015610dc3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610de79190613cd7565b90507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663e7d7146b60066000896001600160a01b03166001600160a01b031681526020019081526020016000206040518060600160405280871515815260200188815260200187610e755773fffd8963efd1fc6a506488495d951d5263988d25610e7c565b6401000276a45b6001600160a01b03169052610e944262989680613bd3565b6040518463ffffffff1660e01b8152600401610eb293929190613cf0565b60408051808303816000875af1158015610ed0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ef49190613d30565b50506040516370a0823160e01b81526001600160a01b038716906370a0823190610f22903090600401613371565b602060405180830381865afa158015610f3f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f639190613cd7565b811015610fec57610fec863383896001600160a01b03166370a08231306040518263ffffffff1660e01b8152600401610f9c9190613371565b602060405180830381865afa158015610fb9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fdd9190613cd7565b610fe79190613d54565b6128cb565b6005546040516370a0823160e01b81526001600160a01b03909116906370a082319061101c903090600401613371565b602060405180830381865afa158015611039573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061105d9190613cd7565b82101561109c576005546040516370a0823160e01b815261109c916001600160a01b0316903390859083906370a0823190610f9c903090600401613371565b505050505050565b6110b084333086612a12565b6000806110bc84612b14565b905060006110c984612b14565b6005549091506001600160a01b0390811690881610156110f5576110ee828288612f2b565b9250611103565b611100828288612f95565b92505b6004805460405163140e25ad60e31b8152676765c793fa10079d601b1b9281018390526001600160a01b039091169063a0712d6890602401600060405180830381600087803b15801561115557600080fd5b505af1158015611169573d6000803e3d6000fd5b50506005546111a592506001600160a01b031690507f0000000000000000000000000000000000000000000000000000000000000000836128cb565b6111d0887f0000000000000000000000000000000000000000000000000000000000000000896128cb565b6000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663f5ea597c600660008d6001600160a01b03166001600160a01b0316815260200190815260200160002060405180606001604052808c60020b81526020018b60020b81526020018a600f0b815250426298968061125a9190613bd3565b6040518463ffffffff1660e01b815260040161127893929190613d67565b60408051808303816000875af1158015611296573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112ba9190613d30565b60055491935091506001600160a01b03908116908b161015611351576112e18a33846128cb565b6004546001600160a01b03166342966c686112fc8386613d54565b6040518263ffffffff1660e01b815260040161131a91815260200190565b600060405180830381600087803b15801561133457600080fd5b505af1158015611348573d6000803e3d6000fd5b505050506113c8565b61135c8a33836128cb565b6004546001600160a01b03166342966c686113778486613d54565b6040518263ffffffff1660e01b815260040161139591815260200190565b600060405180830381600087803b1580156113af57600080fd5b505af11580156113c3573d6000803e3d6000fd5b505050505b50505050505050505050565b6113e085333087612a12565b6005546000906001906001600160a01b03908116908816101561141a57600191508015158214611411576000611414565b60015b50611430565b60009150801561142b57600161142e565b60005b505b61145b877f0000000000000000000000000000000000000000000000000000000000000000886128cb565b6000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663e7d7146b600660008c6001600160a01b03166001600160a01b03168152602001908152602001600020604051806060016040528088151581526020018c8152602001886114ea5773fffd8963efd1fc6a506488495d951d5263988d256114f1565b6401000276a45b6001600160a01b031690526115094262989680613bd3565b6040518463ffffffff1660e01b815260040161152793929190613cf0565b60408051808303816000875af1158015611545573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115699190613d30565b915091506115808261157a90613da3565b82612fcb565b82156115aa57831561159d5761159581613da3565b600b556115aa565b6115a682613da3565b600b555b63ffffffff87166000908152600960205260408120546001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081169163fa31de01918b916115fe9116613012565b600b548b8b60405160200161162f939291909283526001600160a01b03918216602084015216604082015260600190565b60408051601f1981840301815290829052611651916000903390602001613dbf565b6040516020818303038152906040526040518463ffffffff1660e01b815260040161167e93929190613df5565b6020604051808303816000875af115801561169d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116c19190613cd7565b90507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166311bf2c1834838b62030d40306040518663ffffffff1660e01b81526004016117199493929190613e1a565b6000604051808303818588803b15801561173257600080fd5b505af1158015611746573d6000803e3d6000fd5b505050505050505050505050505050565b60008054610bb89082906117719063ffffffff1642613e44565b9050603c611780826064613e61565b61178a9190613e9e565b6117949083613ec0565b925050505b95945050505050565b6000604051630a85dc2960e01b815260040160405180910390fd5b60028054600091826117ce83613edc565b90915550506001600160a01b03861630146117e857600080fd5b506301a206c160e51b95945050505050565b63ffffffff8116600090815260096020526040812054620186a091906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081169163fa31de019186916118549116613012565b336040516020016118659190613371565b6040516020818303038152906040526040518463ffffffff1660e01b815260040161189293929190613df5565b6020604051808303816000875af11580156118b1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118d59190613cd7565b90507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166311bf2c1834838686306040518663ffffffff1660e01b815260040161192a9493929190613e1a565b6000604051808303818588803b15801561194357600080fd5b505af1158015611957573d6000803e3d6000fd5b5050505050505050565b6008805490600061197183613edc565b909155506000905080808061198885870187613ef5565b9250925092508160ff16600003611c8d576000806000858060200190518101906119b29190613f53565b9250925092508460ff16600003611c89576004805460405163140e25ad60e31b81529182018590526001600160a01b03169063a0712d6890602401600060405180830381600087803b158015611a0757600080fd5b505af1158015611a1b573d6000803e3d6000fd5b50506040516370a0823160e01b8152600092506001600160a01b03851691506370a0823190611a4e903090600401613371565b602060405180830381865afa158015611a6b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a8f9190613cd7565b6005549091506000906001600160a01b039081169085161015611ab457506000611ab8565b5060015b600554611aef906001600160a01b03167f0000000000000000000000000000000000000000000000000000000000000000876128cb565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663e7d7146b60066000876001600160a01b03166001600160a01b031681526020019081526020016000206040518060600160405280851515815260200189815260200185611b7b5773fffd8963efd1fc6a506488495d951d5263988d25611b82565b6401000276a45b6001600160a01b03169052611b9a4262989680613bd3565b6040518463ffffffff1660e01b8152600401611bb893929190613cf0565b60408051808303816000875af1158015611bd6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611bfa9190613d30565b50506040516370a0823160e01b81526000906001600160a01b038616906370a0823190611c2b903090600401613371565b602060405180830381865afa158015611c48573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c6c9190613cd7565b905082811115611c8557611c858585610fe78685613d54565b5050505b5050505b8160ff166001036119575760008084806020019051810190611caf9190613d30565b600a54600160a01b900463ffffffff166000908152600e6020526040812080549395509193508392611ce2908490613bd3565b9091555050600a54600160a01b900463ffffffff1660009081526010602052604081208054849290611d15908490613bd3565b909155505050505050505050505050565b6000611d546040518060400160405280600b81526020016a04265666f726520537761760ac1b81525061301e565b60018054906000611d6483613edc565b90915550506005546000906001600160a01b0316611d85602088018861363d565b6001600160a01b031614611da557611da0602087018761363d565b611db5565b611db5604087016020880161363d565b600a54600160a01b900463ffffffff166000908152601060209081526040808320546001600160a01b038516845260119092528220549293509091611dfa9190613bd3565b9050611e2d816040518060400160405280600f81526020016e1a5cc8189bdbdcdd08185b5bdd5b9d608a1b815250613064565b600554611e64906001600160a01b03167f0000000000000000000000000000000000000000000000000000000000000000836128cb565b600a54600160a01b900463ffffffff166000908152600e60209081526040808320546001600160a01b0386168452600f90925290912054611ea59190613bd3565b811115611ebe57506315d7892d60e21b91506117999050565b8015612156576005546001600160a01b039081169083161015611f96576001600160a01b0382811660009081526006602052604081207f000000000000000000000000000000000000000000000000000000000000000090921691637a54f20a9184611f2e426305f5e100613bd3565b6040518563ffffffff1660e01b8152600401611f4d9493929190613f8b565b60408051808303816000875af1158015611f6b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f8f9190613d30565b5050612156565b6040516370a0823160e01b815261202c906001600160a01b038416906370a0823190611fe6907f000000000000000000000000000000000000000000000000000000000000000090600401613371565b602060405180830381865afa158015612003573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906120279190613cd7565b6130a9565b6001600160a01b0382811660009081526006602052604081207f000000000000000000000000000000000000000000000000000000000000000090921691637a54f20a91849061207f4262989680613bd3565b6040518563ffffffff1660e01b815260040161209e9493929190613f8b565b60408051808303816000875af11580156120bc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906120e09190613d30565b50506040516370a0823160e01b8152612132906001600160a01b038416906370a0823190611fe6907f000000000000000000000000000000000000000000000000000000000000000090600401613371565b612156604051806040016040528060038152602001622334b760e91b81525061301e565b6001600160a01b038216600090815260116020908152604080832054600f909252822080549192909161218a908490613d54565b909155506315d7892d60e21b9998505050505050505050565b6060336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146121ee5760405163570c108560e11b815260040160405180910390fd5b600080306001600160a01b0316858560405161220b929190613fb5565b6000604051808303816000865af19150503d8060008114612248576040519150601f19603f3d011682016040523d82523d6000602084013e61224d565b606091505b5091509150811561226157915061228b9050565b8051600003612283576040516314815f4760e31b815260040160405180910390fd5b805160208201fd5b92915050565b60408051808201909152600781526620a6b7bab73a1d60c91b60208201526122c2906122bd8587613fc5565b6129c9565b6005546122e3906001600160a01b031633306122de8789613fc5565b612a12565b60408051608081018252858152600c54602080830182815283850188815233606086019081526000948552600d90935294832093518455516001840155925160028301559151600390910180546001600160a01b0319166001600160a01b039092169190911790555b825181101561241857836011600085848151811061236c5761236c613fdc565b60200260200101516001600160a01b03166001600160a01b0316815260200190815260200160002060008282546123a39190613bd3565b909155506123b390508585613fc5565b600f60008584815181106123c9576123c9613fdc565b60200260200101516001600160a01b03166001600160a01b0316815260200190815260200160002060008282546124009190613bd3565b9091555081905061241081613edc565b91505061234c565b5050505050565b600380546000918261243083613edc565b9091555063b47b2fb160e01b98975050505050505050565b6040805160a0810182526000808252602082018190529181018290526060810182905260808101919091526005546001600160a01b0390811690851610156124c857506040805160a0810182526001600160a01b038086168252600554166020820152610bb891810191909152603c606082015260006080820152612502565b506040805160a0810182526005546001600160a01b03908116825285166020820152610bb891810191909152603c60608201523060808201525b60405163695c5bf560e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063695c5bf59061255290849087908790600401613ff2565b6020604051808303816000875af1158015612571573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906125959190614052565b506001600160a01b03938416600090815260066020908152604091829020835181546001600160a01b031990811691891691909117825591840151600182018054948601516060870151928a166001600160b81b031990961695909517600160a01b62ffffff968716021762ffffff60b81b1916600160b81b959092169490940217909255608090920151600290910180549092169416939093179092555050565b600554612653906001600160a01b031633306122de8688613fc5565b60408051608081018252848152600c54602080830182815283850187815233606086019081526000948552600d90935294832093518455516001840155925160028301559151600390910180546001600160a01b0319166001600160a01b039092169190911790555b81518110156128c55760007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663fa31de0184848151811061270857612708613fdc565b60200260200101516127586009600088888151811061272957612729613fdc565b60209081029190910181015163ffffffff168252810191909152604001600020546001600160a01b0316613012565b876127638a82613fc5565b60408051602081019390935282015260600160408051601f1981840301815290829052612797916001903390602001613dbf565b6040516020818303038152906040526040518463ffffffff1660e01b81526004016127c493929190613df5565b6020604051808303816000875af11580156127e3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906128079190613cd7565b90507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166311bf2c1866071afd498d00008386868151811061285357612853613fdc565b6020026020010151620186a0306040518663ffffffff1660e01b815260040161287f9493929190613e1a565b6000604051808303818588803b15801561289857600080fd5b505af11580156128ac573d6000803e3d6000fd5b50505050505080806128bd90613edc565b9150506126bc565b50505050565b604080516001600160a01b038481166024830152604480830185905283518084039091018152606490920183526020820180516001600160e01b031663a9059cbb60e01b1790529151600092839290871691612927919061406f565b6000604051808303816000865af19150503d8060008114612964576040519150601f19603f3d011682016040523d82523d6000602084013e612969565b606091505b5091509150818015612993575080511580612993575080806020019051810190612993919061408b565b6124185760405162461bcd60e51b815260206004820152600260248201526114d560f21b60448201526064015b60405180910390fd5b612a0e82826040516024016129df9291906140a8565b60408051601f198184030181529190526020810180516001600160e01b0316632d839cb360e21b1790526130ea565b5050565b604080516001600160a01b0385811660248301528481166044830152606480830185905283518084039091018152608490920183526020820180516001600160e01b03166323b872dd60e01b1790529151600092839290881691612a76919061406f565b6000604051808303816000865af19150503d8060008114612ab3576040519150601f19603f3d011682016040523d82523d6000602084013e612ab8565b606091505b5091509150818015612ae2575080511580612ae2575080806020019051810190612ae2919061408b565b61109c5760405162461bcd60e51b815260206004820152600360248201526229aa2360e91b60448201526064016129c0565b60008060008360020b12612b2b578260020b612b38565b8260020b612b3890613da3565b9050612b47620d89e7196140ca565b62ffffff16811115612b7f5760405162461bcd60e51b81526020600482015260016024820152601560fa1b60448201526064016129c0565b600081600116600003612b9657600160801b612ba8565b6ffffcb933bd6fad37aa2d162d1a5940015b6001600160881b031690506002821615612bdd576080612bd8826ffff97272373d413259a46990580e213a613fc5565b901c90505b6004821615612c07576080612c02826ffff2e50f5f656932ef12357cf3c7fdcc613fc5565b901c90505b6008821615612c31576080612c2c826fffe5caca7e10e4e61c3624eaa0941cd0613fc5565b901c90505b6010821615612c5b576080612c56826fffcb9843d60f6159c9db58835c926644613fc5565b901c90505b6020821615612c85576080612c80826fff973b41fa98c081472e6896dfb254c0613fc5565b901c90505b6040821615612caf576080612caa826fff2ea16466c96a3843ec78b326b52861613fc5565b901c90505b6080821615612cd9576080612cd4826ffe5dee046a99a2a811c461f1969c3053613fc5565b901c90505b610100821615612d04576080612cff826ffcbe86c7900a88aedcffc83b479aa3a4613fc5565b901c90505b610200821615612d2f576080612d2a826ff987a7253ac413176f2b074cf7815e54613fc5565b901c90505b610400821615612d5a576080612d55826ff3392b0822b70005940c7a398e4b70f3613fc5565b901c90505b610800821615612d85576080612d80826fe7159475a2c29b7443b29c7fa6e889d9613fc5565b901c90505b611000821615612db0576080612dab826fd097f3bdfd2022b8845ad8f792aa5825613fc5565b901c90505b612000821615612ddb576080612dd6826fa9f746462d870fdf8a65dc1f90e061e5613fc5565b901c90505b614000821615612e06576080612e01826f70d869a156d2a1b890bb3df62baf32f7613fc5565b901c90505b618000821615612e31576080612e2c826f31be135f97d08fd981231505542fcfa6613fc5565b901c90505b62010000821615612e5d576080612e58826f09aa508b5b7a84e1c677de54f3e99bc9613fc5565b901c90505b62020000821615612e88576080612e83826e5d6af8dedb81196699c329225ee604613fc5565b901c90505b62040000821615612eb2576080612ead826d2216e584f5fa1ea926041bedfe98613fc5565b901c90505b62080000821615612eda576080612ed5826b048a170391f7dc42444e8fa2613fc5565b901c90505b60008460020b1315612ef557612ef2816000196140e3565b90505b612f03600160201b826140f7565b15612f0f576001612f12565b60005b612f239060ff16602083901c613bd3565b949350505050565b6000826001600160a01b0316846001600160a01b03161115612f4b579192915b6000612f6e856001600160a01b0316856001600160a01b0316600160601b6130f3565b9050611799612f908483612f82898961410b565b6001600160a01b03166130f3565b613277565b6000826001600160a01b0316846001600160a01b03161115612fb5579192915b612f23612f9083600160601b612f82888861410b565b6040516024810183905260448101829052612a0e9060640160408051601f198184030181529190526020810180516001600160e01b0316637b3338ad60e11b1790526130ea565b6001600160a01b031690565b61306181604051602401613032919061386d565b60408051601f198184030181529190526020810180516001600160e01b031663104c13eb60e21b1790526130ea565b50565b612a0e828260405160240161307a92919061412b565b60408051601f198184030181529190526020810180516001600160e01b031663643fd0df60e01b1790526130ea565b613061816040516024016130bf91815260200190565b60408051601f198184030181529190526020810180516001600160e01b031663f82c50f160e01b1790525b61306181613292565b600080806000198587098587029250828110838203039150508060000361312c576000841161312157600080fd5b508290049050610c7b565b80841161313857600080fd5b60008486880980840393811190920391905060008561315981600019613d54565b613164906001613bd3565b169586900495938490049360008190030460010190506131848184613fc5565b909317926000613195876003613fc5565b60021890506131a48188613fc5565b6131af906002613d54565b6131b99082613fc5565b90506131c58188613fc5565b6131d0906002613d54565b6131da9082613fc5565b90506131e68188613fc5565b6131f1906002613d54565b6131fb9082613fc5565b90506132078188613fc5565b613212906002613d54565b61321c9082613fc5565b90506132288188613fc5565b613233906002613d54565b61323d9082613fc5565b90506132498188613fc5565b613254906002613d54565b61325e9082613fc5565b905061326a8186613fc5565b9998505050505050505050565b806001600160801b038116811461328d57600080fd5b919050565b60006a636f6e736f6c652e6c6f679050600080835160208501845afa505050565b6001600160a01b038116811461306157600080fd5b8060020b811461306157600080fd5b6000806000606084860312156132ec57600080fd5b83356132f7816132b3565b92506020840135613307816132c8565b91506040840135613317816132c8565b809150509250925092565b801515811461306157600080fd5b60008060006060848603121561334557600080fd5b8335613350816132b3565b9250602084013561336081613322565b929592945050506040919091013590565b6001600160a01b0391909116815260200190565b6000806000806080858703121561339b57600080fd5b84356133a6816132b3565b93506020850135925060408501356133bd816132c8565b915060608501356133cd816132c8565b939692955090935050565b803563ffffffff8116811461328d57600080fd5b600080600080600060a0868803121561340457600080fd5b853561340f816132b3565b945060208601359350613424604087016133d8565b92506060860135613434816132b3565b91506080860135613444816132b3565b809150509295509295909350565b600060a0828403121561346457600080fd5b50919050565b60006060828403121561346457600080fd5b60008083601f84011261348e57600080fd5b5081356001600160401b038111156134a557600080fd5b6020830191508360208285010111156134bd57600080fd5b9250929050565b600080600080600061014086880312156134dd57600080fd5b85356134e8816132b3565b94506134f78760208801613452565b93506135068760c0880161346a565b92506101208601356001600160401b0381111561352257600080fd5b61352e8882890161347c565b969995985093965092949392505050565b600080600080600080610160878903121561355957600080fd5b8635613564816132b3565b95506135738860208901613452565b94506135828860c0890161346a565b935061012087013592506101408701356001600160401b038111156135a657600080fd5b6135b289828a0161347c565b979a9699509497509295939492505050565b600080600080600061010086880312156135dd57600080fd5b85356135e8816132b3565b94506135f78760208801613452565b935060c0860135613607816132b3565b925060e08601356001600160401b0381111561352257600080fd5b60006020828403121561363457600080fd5b610c7b826133d8565b60006020828403121561364f57600080fd5b8135610c7b816132b3565b6000806000806060858703121561367057600080fd5b613679856133d8565b93506020850135925060408501356001600160401b0381111561369b57600080fd5b6136a78782880161347c565b95989497509550505050565b60006101008201905082511515825260208301511515602083015260408301511515604083015260608301511515606083015260808301516136f9608084018215159052565b5060a083015161370d60a084018215159052565b5060c083015161372160c084018215159052565b5060e083015161373560e084018215159052565b5092915050565b6000806040838503121561374f57600080fd5b823591506020830135613761816132b3565b809150509250929050565b600080600080600080610120878903121561378657600080fd5b8635613791816132b3565b95506137a08860208901613452565b945060c08701356137b0816132b3565b935060e08701356137c0816132c8565b92506101008701356001600160401b038111156135a657600080fd5b600080602083850312156137ef57600080fd5b82356001600160401b0381111561380557600080fd5b6138118582860161347c565b90969095509350505050565b60005b83811015613838578181015183820152602001613820565b50506000910152565b6000815180845261385981602086016020860161381d565b601f01601f19169290920160200192915050565b602081526000610c7b6020830184613841565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b03811182821017156138be576138be613880565b604052919050565b60006001600160401b038211156138df576138df613880565b5060051b60200190565b600082601f8301126138fa57600080fd5b8135602061390f61390a836138c6565b613896565b82815260059290921b8401810191818101908684111561392e57600080fd5b8286015b8481101561395057613943816133d8565b8352918301918301613932565b509695505050505050565b6000806000806080858703121561397157600080fd5b84359350602080860135935060408601356001600160401b038082111561399757600080fd5b818801915088601f8301126139ab57600080fd5b81356139b961390a826138c6565b81815260059190911b8301840190848101908b8311156139d857600080fd5b938501935b828510156139ff5784356139f0816132b3565b825293850193908501906139dd565b965050506060880135925080831115613a1757600080fd5b5050613a25878288016138e9565b91505092959194509250565b6000806000806000806101208789031215613a4b57600080fd5b8635613a56816132b3565b9550613a658860208901613452565b945060c0870135935060e087013592506101008701356001600160401b038111156135a657600080fd5b600060208284031215613aa157600080fd5b5035919050565b600082601f830112613ab957600080fd5b81356001600160401b03811115613ad257613ad2613880565b613ae5601f8201601f1916602001613896565b818152846020838601011115613afa57600080fd5b816020850160208301376000918101602001919091529392505050565b600080600060608486031215613b2c57600080fd5b8335613b37816132b3565b92506020840135613b47816132b3565b915060408401356001600160401b03811115613b6257600080fd5b613b6e86828701613aa8565b9150509250925092565b600080600060608486031215613b8d57600080fd5b833592506020840135915060408401356001600160401b03811115613bb157600080fd5b613b6e868287016138e9565b634e487b7160e01b600052601160045260246000fd5b8082018082111561228b5761228b613bbd565b80546001600160a01b0390811683526001820154808216602085015260a081901c62ffffff16604085015260b81c600290810b60608501529091015416608090910152565b6101008101613c3a8287613be6565b8460020b60a08301528360020b60c08301528260e083015295945050505050565b8051600f81900b811461328d57600080fd5b60008060408385031215613c8057600080fd5b613c8983613c5b565b9150613c9760208401613c5b565b90509250929050565b6000600f82900b6001607f1b8101613cba57613cba613bbd565b60000392915050565b6001600160801b0391909116815260200190565b600060208284031215613ce957600080fd5b5051919050565b6101208101613cff8286613be6565b8351151560a0830152602084015160c08301526040909301516001600160a01b031660e08201526101000152919050565b60008060408385031215613d4357600080fd5b505080516020909101519092909150565b8181038181111561228b5761228b613bbd565b6101208101613d768286613be6565b8351600290810b60a08401526020850151900b60c083015260409093015160e08201526101000152919050565b6000600160ff1b8201613db857613db8613bbd565b5060000390565b606081526000613dd26060830186613841565b60ff949094166020830152506001600160a01b0391909116604090910152919050565b63ffffffff841681528260208201526060604082015260006117996060830184613841565b93845263ffffffff92909216602084015260408301526001600160a01b0316606082015260800190565b63ffffffff82811682821603908082111561373557613735613bbd565b62ffffff818116838216028082169190828114613e8057613e80613bbd565b505092915050565b634e487b7160e01b600052601260045260246000fd5b600062ffffff80841680613eb457613eb4613e88565b92169190910492915050565b62ffffff81811683821601908082111561373557613735613bbd565b600060018201613eee57613eee613bbd565b5060010190565b600080600060608486031215613f0a57600080fd5b83356001600160401b03811115613f2057600080fd5b613f2c86828701613aa8565b935050602084013560ff81168114613f4357600080fd5b91506040840135613317816132b3565b600080600060608486031215613f6857600080fd5b835192506020840151613f7a816132b3565b6040850151909250613317816132b3565b6101008101613f9a8287613be6565b8460a08301528360c08301528260e083015295945050505050565b8183823760009101908152919050565b808202811582820484141761228b5761228b613bbd565b634e487b7160e01b600052603260045260246000fd5b600060018060a01b0380865116835280602087015116602084015262ffffff6040870151166040840152606086015160020b606084015280608087015116608084015280851660a08401525060e060c083015261179960e0830184613841565b60006020828403121561406457600080fd5b8151610c7b816132c8565b6000825161408181846020870161381d565b9190910192915050565b60006020828403121561409d57600080fd5b8151610c7b81613322565b6040815260006140bb6040830185613841565b90508260208301529392505050565b60008160020b627fffff198103613cba57613cba613bbd565b6000826140f2576140f2613e88565b500490565b60008261410657614106613e88565b500690565b6001600160a01b0382811682821603908082111561373557613735613bbd565b828152604060208201526000612f23604083018461384156fea2646970667358221220327d906970be24f906e9164f481f11e15585ef386119173aafc26ccf78988b5064736f6c63430008140033a2646970667358221220d3b96c9ae21e71914f3fd96cbf5b62fdf275c655a8519d55a463984970c7d6bd64736f6c63430008140033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100415760003560e01c8063864c17d714610046578063c4ceb78914610075578063f84b2a3f1461008a575b600080fd5b6100596100543660046102b3565b61009d565b6040516001600160a01b03909116815260200160405180910390f35b6100886100833660046102e8565b6100c7565b005b610059610098366004610344565b610174565b600081815481106100ad57600080fd5b6000918252602090912001546001600160a01b0316905081565b6100fa604051806040016040528060128152602001713232b83637bcb4b733903437b7b5b997171760711b81525061023b565b6000818686868660405161010d906102a6565b61011a94939291906103b1565b8190604051809103906000f590508015801561013a573d6000803e3d6000fd5b5081546001810183556000928352602090922090910180546001600160a01b0319166001600160a01b039092169190911790555050505050565b60008060405180602001610187906102a6565b601f1982820381018352601f9091011660408190526101b09089908990899089906020016103b1565b60408051601f19818403018152908290526101ce9291602001610400565b60408051601f1981840301815282825280516020918201206001600160f81b0319828501523060601b6001600160601b0319166021850152603584019690965260558084019690965281518084039096018652607590920190528351930192909220979650505050505050565b61027e8160405160240161024f919061042f565b60408051601f198184030181529190526020810180516001600160e01b031663104c13eb60e21b179052610281565b50565b61027e8160006a636f6e736f6c652e6c6f679050600080835160208501845afa505050565b6144de8061046383390190565b6000602082840312156102c557600080fd5b5035919050565b80356001600160a01b03811681146102e357600080fd5b919050565b600080600080600060a0868803121561030057600080fd5b610309866102cc565b9450610317602087016102cc565b9350610325604087016102cc565b9250610333606087016102cc565b949793965091946080013592915050565b60008060008060008060c0878903121561035d57600080fd5b610366876102cc565b9550610374602088016102cc565b9450610382604088016102cc565b9350610390606088016102cc565b925061039e608088016102cc565b915060a087013590509295509295509295565b6001600160a01b03948516815292841660208401529083166040830152909116606082015260800190565b60005b838110156103f75781810151838201526020016103df565b50506000910152565b600083516104128184602088016103dc565b8351908301906104268183602088016103dc565b01949350505050565b602081526000825180602084015261044e8160408501602087016103dc565b601f01601f1916919091016040019291505056fe610100604052600a805463ffffffff60a01b191690553480156200002257600080fd5b50604051620044de380380620044de83398101604081905262000045916200022c565b6001600160a01b038316608052826200005e3062000080565b506001600160a01b0393841660a05290831660c05290911660e0525062000289565b62000115816200010f6040805161010081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101919091525060408051610100810182526001808252600060208301819052928201839052606082018390526080820181905260a082015260c0810182905260e081019190915290565b62000118565b50565b805115156001609f1b83161515141580620001415750602081015115156001609e1b8316151514155b806200015b5750604081015115156001609d1b8316151514155b80620001755750606081015115156001609c1b8316151514155b806200018f5750608081015115156001609b1b8316151514155b80620001a9575060a081015115156001609a1b8316151514155b80620001c3575060c08101511515600160991b8316151514155b80620001dd575060e08101511515600160981b8316151514155b156200020b57604051630732d7b560e51b81526001600160a01b038316600482015260240160405180910390fd5b5050565b80516001600160a01b03811681146200022757600080fd5b919050565b600080600080608085870312156200024357600080fd5b6200024e856200020f565b93506200025e602086016200020f565b92506200026e604086016200020f565b91506200027e606086016200020f565b905092959194509250565b60805160a05160c05160e05161417a62000364600039600081816109a9015281816116c5015281816118d9015261280b015260008181610557015281816115ca0152818161182001526126c90152600081816105a101528181610a0701528181610cdf01528181610deb01528181611180015281816111ab015281816111d5015281816114360152818161146001528181611aca01528181611af101528181611e3f01528181611ef601528181611fbe01528181612047015261210a0152600081816108c4015281816121b00152612519015261417a6000f3fe6080604052600436106101fb5760003560e01c806306661abd146102075780630ac10973146102305780631087004a1461025057806312386029146102725780632492963b1461029f5780632794823f146102bf5780632ab7a3e2146102d25780632f1ec5e01461030657806330b7cdef1461031c5780633440d82014610355578063345f0ffa14610375578063346c609e146103885780634deefab2146103b55780634df87c09146103d55780634faaefae1461041557806356d5d47514610435578063575e24b414610455578063612c39b71461047557806369d7e873146105185780636bd5c4e61461054557806378e1abb5146105795780638a6e59461461058f57806391e834a5146105c357806395ae34ed146105f057806396e13e471461061d578063a184a2ce14610633578063a910f80f1461067c578063ab6291fe14610697578063b069f61f146106c4578063b09a078514610766578063b47b2fb114610786578063b6a8b0fa146107a6578063beecd2bd146107c1578063c94bacaa14610808578063d94a7e531461083e578063dc4c90d3146108b2578063de4a787f146108e6578063de523cf314610923578063dff78df714610941578063e1b4af69146107a6578063e8c55a6114610957578063ead0f5a714610977578063f28b2daa14610997578063fe9a6f45146109cb57600080fd5b3661020257005b600080fd5b34801561021357600080fd5b5061021d60085481565b6040519081526020015b60405180910390f35b34801561023c57600080fd5b5061021d61024b3660046132d7565b6109e6565b34801561025c57600080fd5b5061027061026b366004613330565b610c82565b005b34801561027e57600080fd5b50600554610292906001600160a01b031681565b6040516102279190613371565b3480156102ab57600080fd5b506102706102ba366004613385565b6110a4565b6102706102cd3660046133ec565b6113d4565b3480156102de57600080fd5b506102f26102ed3660046134c4565b611757565b60405162ffffff9091168152602001610227565b34801561031257600080fd5b5061021d60025481565b34801561032857600080fd5b5061033c61033736600461353f565b6117a2565b6040516001600160e01b03199091168152602001610227565b34801561036157600080fd5b5061033c6103703660046135c4565b6117bd565b610270610383366004613622565b6117fa565b34801561039457600080fd5b5061021d6103a336600461363d565b600f6020526000908152604090205481565b3480156103c157600080fd5b50600a54610292906001600160a01b031681565b3480156103e157600080fd5b506104056103f036600461363d565b60076020526000908152604090205460ff1681565b6040519015158152602001610227565b34801561042157600080fd5b50600454610292906001600160a01b031681565b34801561044157600080fd5b5061027061045036600461365a565b611961565b34801561046157600080fd5b5061033c6104703660046134c4565b611d26565b34801561048157600080fd5b5061050b6040805161010081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101919091525060408051610100810182526001808252600060208301819052928201839052606082018390526080820181905260a082015260c0810182905260e081019190915290565b60405161022791906136b3565b34801561052457600080fd5b5061021d61053336600461363d565b60116020526000908152604090205481565b34801561055157600080fd5b506102927f000000000000000000000000000000000000000000000000000000000000000081565b34801561058557600080fd5b5061021d600b5481565b34801561059b57600080fd5b506102927f000000000000000000000000000000000000000000000000000000000000000081565b3480156105cf57600080fd5b5061021d6105de366004613622565b600e6020526000908152604090205481565b3480156105fc57600080fd5b5061021d61060b366004613622565b60106020526000908152604090205481565b34801561062957600080fd5b5061021d60015481565b34801561063f57600080fd5b5061027061064e36600461373c565b60009182526009602052604090912080546001600160a01b0319166001600160a01b03909216919091179055565b34801561068857600080fd5b5061033c61033736600461376c565b3480156106a357600080fd5b506106b76106b23660046137dc565b6121a3565b604051610227919061386d565b3480156106d057600080fd5b506107266106df36600461363d565b6006602052600090815260409020805460018201546002928301546001600160a01b03928316938284169362ffffff600160a01b85041693600160b81b900490910b911685565b604080516001600160a01b039687168152948616602086015262ffffff9093169284019290925260020b606083015291909116608082015260a001610227565b34801561077257600080fd5b5061027061078136600461395b565b612291565b34801561079257600080fd5b5061033c6107a136600461353f565b61241f565b3480156107b257600080fd5b5061033c610337366004613a31565b3480156107cd57600080fd5b506102706107dc36600461363d565b600480546001600160a01b039092166001600160a01b0319928316811790915560058054909216179055565b34801561081457600080fd5b50610292610823366004613a8f565b6009602052600090815260409020546001600160a01b031681565b34801561084a57600080fd5b50610889610859366004613a8f565b600d602052600090815260409020805460018201546002830154600390930154919290916001600160a01b031684565b604080519485526020850193909352918301526001600160a01b03166060820152608001610227565b3480156108be57600080fd5b506102927f000000000000000000000000000000000000000000000000000000000000000081565b3480156108f257600080fd5b5061027061090136600461363d565b600a80546001600160a01b0319166001600160a01b0392909216919091179055565b34801561092f57600080fd5b50600a546001600160a01b0316610292565b34801561094d57600080fd5b5061021d60035481565b34801561096357600080fd5b50610270610972366004613b17565b612448565b34801561098357600080fd5b50610270610992366004613b78565b612637565b3480156109a357600080fd5b506102927f000000000000000000000000000000000000000000000000000000000000000081565b3480156109d757600080fd5b5061033c6103373660046134c4565b6001600160a01b0383811660009081526006602052604081209091829182917f00000000000000000000000000000000000000000000000000000000000000001690634ff490fb908787610a3e426305f5e100613bd3565b6040518563ffffffff1660e01b8152600401610a5d9493929190613c2b565b60408051808303816000875af1158015610a7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a9f9190613c6d565b60055491935091506001600160a01b039081169087161015610bb0576001600160a01b03808716600090815260066020526040902054610af2911633610ae485613ca0565b6001600160801b03166128cb565b6004546001600160a01b03166342966c68610b0c83613ca0565b6040518263ffffffff1660e01b8152600401610b289190613cc3565b600060405180830381600087803b158015610b4257600080fd5b505af1158015610b56573d6000803e3d6000fd5b50505050610b956040518060400160405280600781526020016622b0b932b7321d60c91b81525082610b8790613ca0565b6001600160801b03166129c9565b610b9e82613ca0565b6001600160801b031692505050610c7b565b6001600160a01b03808716600090815260066020526040902060010154610bdc911633610ae484613ca0565b610c096040518060400160405280600781526020016622b0b932b7321d60c91b81525083610b8790613ca0565b6004546001600160a01b03166342966c68610c2384613ca0565b6040518263ffffffff1660e01b8152600401610c3f9190613cc3565b600060405180830381600087803b158015610c5957600080fd5b505af1158015610c6d573d6000803e3d6000fd5b5050505080610b9e90613ca0565b9392505050565b610c8e83333084612a12565b6005546000906001600160a01b039081169085161015610cc4575060018215158114610cbb576000610cbe565b60015b50610cd9565b5060008215610cd4576001610cd7565b60005b505b610d04847f0000000000000000000000000000000000000000000000000000000000000000846128cb565b6005546040516370a0823160e01b81526000916001600160a01b0316906370a0823190610d35903090600401613371565b602060405180830381865afa158015610d52573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d769190613cd7565b90506000856001600160a01b03166370a08231306040518263ffffffff1660e01b8152600401610da69190613371565b602060405180830381865afa158015610dc3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610de79190613cd7565b90507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663e7d7146b60066000896001600160a01b03166001600160a01b031681526020019081526020016000206040518060600160405280871515815260200188815260200187610e755773fffd8963efd1fc6a506488495d951d5263988d25610e7c565b6401000276a45b6001600160a01b03169052610e944262989680613bd3565b6040518463ffffffff1660e01b8152600401610eb293929190613cf0565b60408051808303816000875af1158015610ed0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ef49190613d30565b50506040516370a0823160e01b81526001600160a01b038716906370a0823190610f22903090600401613371565b602060405180830381865afa158015610f3f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f639190613cd7565b811015610fec57610fec863383896001600160a01b03166370a08231306040518263ffffffff1660e01b8152600401610f9c9190613371565b602060405180830381865afa158015610fb9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fdd9190613cd7565b610fe79190613d54565b6128cb565b6005546040516370a0823160e01b81526001600160a01b03909116906370a082319061101c903090600401613371565b602060405180830381865afa158015611039573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061105d9190613cd7565b82101561109c576005546040516370a0823160e01b815261109c916001600160a01b0316903390859083906370a0823190610f9c903090600401613371565b505050505050565b6110b084333086612a12565b6000806110bc84612b14565b905060006110c984612b14565b6005549091506001600160a01b0390811690881610156110f5576110ee828288612f2b565b9250611103565b611100828288612f95565b92505b6004805460405163140e25ad60e31b8152676765c793fa10079d601b1b9281018390526001600160a01b039091169063a0712d6890602401600060405180830381600087803b15801561115557600080fd5b505af1158015611169573d6000803e3d6000fd5b50506005546111a592506001600160a01b031690507f0000000000000000000000000000000000000000000000000000000000000000836128cb565b6111d0887f0000000000000000000000000000000000000000000000000000000000000000896128cb565b6000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663f5ea597c600660008d6001600160a01b03166001600160a01b0316815260200190815260200160002060405180606001604052808c60020b81526020018b60020b81526020018a600f0b815250426298968061125a9190613bd3565b6040518463ffffffff1660e01b815260040161127893929190613d67565b60408051808303816000875af1158015611296573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112ba9190613d30565b60055491935091506001600160a01b03908116908b161015611351576112e18a33846128cb565b6004546001600160a01b03166342966c686112fc8386613d54565b6040518263ffffffff1660e01b815260040161131a91815260200190565b600060405180830381600087803b15801561133457600080fd5b505af1158015611348573d6000803e3d6000fd5b505050506113c8565b61135c8a33836128cb565b6004546001600160a01b03166342966c686113778486613d54565b6040518263ffffffff1660e01b815260040161139591815260200190565b600060405180830381600087803b1580156113af57600080fd5b505af11580156113c3573d6000803e3d6000fd5b505050505b50505050505050505050565b6113e085333087612a12565b6005546000906001906001600160a01b03908116908816101561141a57600191508015158214611411576000611414565b60015b50611430565b60009150801561142b57600161142e565b60005b505b61145b877f0000000000000000000000000000000000000000000000000000000000000000886128cb565b6000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663e7d7146b600660008c6001600160a01b03166001600160a01b03168152602001908152602001600020604051806060016040528088151581526020018c8152602001886114ea5773fffd8963efd1fc6a506488495d951d5263988d256114f1565b6401000276a45b6001600160a01b031690526115094262989680613bd3565b6040518463ffffffff1660e01b815260040161152793929190613cf0565b60408051808303816000875af1158015611545573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115699190613d30565b915091506115808261157a90613da3565b82612fcb565b82156115aa57831561159d5761159581613da3565b600b556115aa565b6115a682613da3565b600b555b63ffffffff87166000908152600960205260408120546001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081169163fa31de01918b916115fe9116613012565b600b548b8b60405160200161162f939291909283526001600160a01b03918216602084015216604082015260600190565b60408051601f1981840301815290829052611651916000903390602001613dbf565b6040516020818303038152906040526040518463ffffffff1660e01b815260040161167e93929190613df5565b6020604051808303816000875af115801561169d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116c19190613cd7565b90507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166311bf2c1834838b62030d40306040518663ffffffff1660e01b81526004016117199493929190613e1a565b6000604051808303818588803b15801561173257600080fd5b505af1158015611746573d6000803e3d6000fd5b505050505050505050505050505050565b60008054610bb89082906117719063ffffffff1642613e44565b9050603c611780826064613e61565b61178a9190613e9e565b6117949083613ec0565b925050505b95945050505050565b6000604051630a85dc2960e01b815260040160405180910390fd5b60028054600091826117ce83613edc565b90915550506001600160a01b03861630146117e857600080fd5b506301a206c160e51b95945050505050565b63ffffffff8116600090815260096020526040812054620186a091906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081169163fa31de019186916118549116613012565b336040516020016118659190613371565b6040516020818303038152906040526040518463ffffffff1660e01b815260040161189293929190613df5565b6020604051808303816000875af11580156118b1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118d59190613cd7565b90507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166311bf2c1834838686306040518663ffffffff1660e01b815260040161192a9493929190613e1a565b6000604051808303818588803b15801561194357600080fd5b505af1158015611957573d6000803e3d6000fd5b5050505050505050565b6008805490600061197183613edc565b909155506000905080808061198885870187613ef5565b9250925092508160ff16600003611c8d576000806000858060200190518101906119b29190613f53565b9250925092508460ff16600003611c89576004805460405163140e25ad60e31b81529182018590526001600160a01b03169063a0712d6890602401600060405180830381600087803b158015611a0757600080fd5b505af1158015611a1b573d6000803e3d6000fd5b50506040516370a0823160e01b8152600092506001600160a01b03851691506370a0823190611a4e903090600401613371565b602060405180830381865afa158015611a6b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a8f9190613cd7565b6005549091506000906001600160a01b039081169085161015611ab457506000611ab8565b5060015b600554611aef906001600160a01b03167f0000000000000000000000000000000000000000000000000000000000000000876128cb565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663e7d7146b60066000876001600160a01b03166001600160a01b031681526020019081526020016000206040518060600160405280851515815260200189815260200185611b7b5773fffd8963efd1fc6a506488495d951d5263988d25611b82565b6401000276a45b6001600160a01b03169052611b9a4262989680613bd3565b6040518463ffffffff1660e01b8152600401611bb893929190613cf0565b60408051808303816000875af1158015611bd6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611bfa9190613d30565b50506040516370a0823160e01b81526000906001600160a01b038616906370a0823190611c2b903090600401613371565b602060405180830381865afa158015611c48573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c6c9190613cd7565b905082811115611c8557611c858585610fe78685613d54565b5050505b5050505b8160ff166001036119575760008084806020019051810190611caf9190613d30565b600a54600160a01b900463ffffffff166000908152600e6020526040812080549395509193508392611ce2908490613bd3565b9091555050600a54600160a01b900463ffffffff1660009081526010602052604081208054849290611d15908490613bd3565b909155505050505050505050505050565b6000611d546040518060400160405280600b81526020016a04265666f726520537761760ac1b81525061301e565b60018054906000611d6483613edc565b90915550506005546000906001600160a01b0316611d85602088018861363d565b6001600160a01b031614611da557611da0602087018761363d565b611db5565b611db5604087016020880161363d565b600a54600160a01b900463ffffffff166000908152601060209081526040808320546001600160a01b038516845260119092528220549293509091611dfa9190613bd3565b9050611e2d816040518060400160405280600f81526020016e1a5cc8189bdbdcdd08185b5bdd5b9d608a1b815250613064565b600554611e64906001600160a01b03167f0000000000000000000000000000000000000000000000000000000000000000836128cb565b600a54600160a01b900463ffffffff166000908152600e60209081526040808320546001600160a01b0386168452600f90925290912054611ea59190613bd3565b811115611ebe57506315d7892d60e21b91506117999050565b8015612156576005546001600160a01b039081169083161015611f96576001600160a01b0382811660009081526006602052604081207f000000000000000000000000000000000000000000000000000000000000000090921691637a54f20a9184611f2e426305f5e100613bd3565b6040518563ffffffff1660e01b8152600401611f4d9493929190613f8b565b60408051808303816000875af1158015611f6b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f8f9190613d30565b5050612156565b6040516370a0823160e01b815261202c906001600160a01b038416906370a0823190611fe6907f000000000000000000000000000000000000000000000000000000000000000090600401613371565b602060405180830381865afa158015612003573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906120279190613cd7565b6130a9565b6001600160a01b0382811660009081526006602052604081207f000000000000000000000000000000000000000000000000000000000000000090921691637a54f20a91849061207f4262989680613bd3565b6040518563ffffffff1660e01b815260040161209e9493929190613f8b565b60408051808303816000875af11580156120bc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906120e09190613d30565b50506040516370a0823160e01b8152612132906001600160a01b038416906370a0823190611fe6907f000000000000000000000000000000000000000000000000000000000000000090600401613371565b612156604051806040016040528060038152602001622334b760e91b81525061301e565b6001600160a01b038216600090815260116020908152604080832054600f909252822080549192909161218a908490613d54565b909155506315d7892d60e21b9998505050505050505050565b6060336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146121ee5760405163570c108560e11b815260040160405180910390fd5b600080306001600160a01b0316858560405161220b929190613fb5565b6000604051808303816000865af19150503d8060008114612248576040519150601f19603f3d011682016040523d82523d6000602084013e61224d565b606091505b5091509150811561226157915061228b9050565b8051600003612283576040516314815f4760e31b815260040160405180910390fd5b805160208201fd5b92915050565b60408051808201909152600781526620a6b7bab73a1d60c91b60208201526122c2906122bd8587613fc5565b6129c9565b6005546122e3906001600160a01b031633306122de8789613fc5565b612a12565b60408051608081018252858152600c54602080830182815283850188815233606086019081526000948552600d90935294832093518455516001840155925160028301559151600390910180546001600160a01b0319166001600160a01b039092169190911790555b825181101561241857836011600085848151811061236c5761236c613fdc565b60200260200101516001600160a01b03166001600160a01b0316815260200190815260200160002060008282546123a39190613bd3565b909155506123b390508585613fc5565b600f60008584815181106123c9576123c9613fdc565b60200260200101516001600160a01b03166001600160a01b0316815260200190815260200160002060008282546124009190613bd3565b9091555081905061241081613edc565b91505061234c565b5050505050565b600380546000918261243083613edc565b9091555063b47b2fb160e01b98975050505050505050565b6040805160a0810182526000808252602082018190529181018290526060810182905260808101919091526005546001600160a01b0390811690851610156124c857506040805160a0810182526001600160a01b038086168252600554166020820152610bb891810191909152603c606082015260006080820152612502565b506040805160a0810182526005546001600160a01b03908116825285166020820152610bb891810191909152603c60608201523060808201525b60405163695c5bf560e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063695c5bf59061255290849087908790600401613ff2565b6020604051808303816000875af1158015612571573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906125959190614052565b506001600160a01b03938416600090815260066020908152604091829020835181546001600160a01b031990811691891691909117825591840151600182018054948601516060870151928a166001600160b81b031990961695909517600160a01b62ffffff968716021762ffffff60b81b1916600160b81b959092169490940217909255608090920151600290910180549092169416939093179092555050565b600554612653906001600160a01b031633306122de8688613fc5565b60408051608081018252848152600c54602080830182815283850187815233606086019081526000948552600d90935294832093518455516001840155925160028301559151600390910180546001600160a01b0319166001600160a01b039092169190911790555b81518110156128c55760007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663fa31de0184848151811061270857612708613fdc565b60200260200101516127586009600088888151811061272957612729613fdc565b60209081029190910181015163ffffffff168252810191909152604001600020546001600160a01b0316613012565b876127638a82613fc5565b60408051602081019390935282015260600160408051601f1981840301815290829052612797916001903390602001613dbf565b6040516020818303038152906040526040518463ffffffff1660e01b81526004016127c493929190613df5565b6020604051808303816000875af11580156127e3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906128079190613cd7565b90507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166311bf2c1866071afd498d00008386868151811061285357612853613fdc565b6020026020010151620186a0306040518663ffffffff1660e01b815260040161287f9493929190613e1a565b6000604051808303818588803b15801561289857600080fd5b505af11580156128ac573d6000803e3d6000fd5b50505050505080806128bd90613edc565b9150506126bc565b50505050565b604080516001600160a01b038481166024830152604480830185905283518084039091018152606490920183526020820180516001600160e01b031663a9059cbb60e01b1790529151600092839290871691612927919061406f565b6000604051808303816000865af19150503d8060008114612964576040519150601f19603f3d011682016040523d82523d6000602084013e612969565b606091505b5091509150818015612993575080511580612993575080806020019051810190612993919061408b565b6124185760405162461bcd60e51b815260206004820152600260248201526114d560f21b60448201526064015b60405180910390fd5b612a0e82826040516024016129df9291906140a8565b60408051601f198184030181529190526020810180516001600160e01b0316632d839cb360e21b1790526130ea565b5050565b604080516001600160a01b0385811660248301528481166044830152606480830185905283518084039091018152608490920183526020820180516001600160e01b03166323b872dd60e01b1790529151600092839290881691612a76919061406f565b6000604051808303816000865af19150503d8060008114612ab3576040519150601f19603f3d011682016040523d82523d6000602084013e612ab8565b606091505b5091509150818015612ae2575080511580612ae2575080806020019051810190612ae2919061408b565b61109c5760405162461bcd60e51b815260206004820152600360248201526229aa2360e91b60448201526064016129c0565b60008060008360020b12612b2b578260020b612b38565b8260020b612b3890613da3565b9050612b47620d89e7196140ca565b62ffffff16811115612b7f5760405162461bcd60e51b81526020600482015260016024820152601560fa1b60448201526064016129c0565b600081600116600003612b9657600160801b612ba8565b6ffffcb933bd6fad37aa2d162d1a5940015b6001600160881b031690506002821615612bdd576080612bd8826ffff97272373d413259a46990580e213a613fc5565b901c90505b6004821615612c07576080612c02826ffff2e50f5f656932ef12357cf3c7fdcc613fc5565b901c90505b6008821615612c31576080612c2c826fffe5caca7e10e4e61c3624eaa0941cd0613fc5565b901c90505b6010821615612c5b576080612c56826fffcb9843d60f6159c9db58835c926644613fc5565b901c90505b6020821615612c85576080612c80826fff973b41fa98c081472e6896dfb254c0613fc5565b901c90505b6040821615612caf576080612caa826fff2ea16466c96a3843ec78b326b52861613fc5565b901c90505b6080821615612cd9576080612cd4826ffe5dee046a99a2a811c461f1969c3053613fc5565b901c90505b610100821615612d04576080612cff826ffcbe86c7900a88aedcffc83b479aa3a4613fc5565b901c90505b610200821615612d2f576080612d2a826ff987a7253ac413176f2b074cf7815e54613fc5565b901c90505b610400821615612d5a576080612d55826ff3392b0822b70005940c7a398e4b70f3613fc5565b901c90505b610800821615612d85576080612d80826fe7159475a2c29b7443b29c7fa6e889d9613fc5565b901c90505b611000821615612db0576080612dab826fd097f3bdfd2022b8845ad8f792aa5825613fc5565b901c90505b612000821615612ddb576080612dd6826fa9f746462d870fdf8a65dc1f90e061e5613fc5565b901c90505b614000821615612e06576080612e01826f70d869a156d2a1b890bb3df62baf32f7613fc5565b901c90505b618000821615612e31576080612e2c826f31be135f97d08fd981231505542fcfa6613fc5565b901c90505b62010000821615612e5d576080612e58826f09aa508b5b7a84e1c677de54f3e99bc9613fc5565b901c90505b62020000821615612e88576080612e83826e5d6af8dedb81196699c329225ee604613fc5565b901c90505b62040000821615612eb2576080612ead826d2216e584f5fa1ea926041bedfe98613fc5565b901c90505b62080000821615612eda576080612ed5826b048a170391f7dc42444e8fa2613fc5565b901c90505b60008460020b1315612ef557612ef2816000196140e3565b90505b612f03600160201b826140f7565b15612f0f576001612f12565b60005b612f239060ff16602083901c613bd3565b949350505050565b6000826001600160a01b0316846001600160a01b03161115612f4b579192915b6000612f6e856001600160a01b0316856001600160a01b0316600160601b6130f3565b9050611799612f908483612f82898961410b565b6001600160a01b03166130f3565b613277565b6000826001600160a01b0316846001600160a01b03161115612fb5579192915b612f23612f9083600160601b612f82888861410b565b6040516024810183905260448101829052612a0e9060640160408051601f198184030181529190526020810180516001600160e01b0316637b3338ad60e11b1790526130ea565b6001600160a01b031690565b61306181604051602401613032919061386d565b60408051601f198184030181529190526020810180516001600160e01b031663104c13eb60e21b1790526130ea565b50565b612a0e828260405160240161307a92919061412b565b60408051601f198184030181529190526020810180516001600160e01b031663643fd0df60e01b1790526130ea565b613061816040516024016130bf91815260200190565b60408051601f198184030181529190526020810180516001600160e01b031663f82c50f160e01b1790525b61306181613292565b600080806000198587098587029250828110838203039150508060000361312c576000841161312157600080fd5b508290049050610c7b565b80841161313857600080fd5b60008486880980840393811190920391905060008561315981600019613d54565b613164906001613bd3565b169586900495938490049360008190030460010190506131848184613fc5565b909317926000613195876003613fc5565b60021890506131a48188613fc5565b6131af906002613d54565b6131b99082613fc5565b90506131c58188613fc5565b6131d0906002613d54565b6131da9082613fc5565b90506131e68188613fc5565b6131f1906002613d54565b6131fb9082613fc5565b90506132078188613fc5565b613212906002613d54565b61321c9082613fc5565b90506132288188613fc5565b613233906002613d54565b61323d9082613fc5565b90506132498188613fc5565b613254906002613d54565b61325e9082613fc5565b905061326a8186613fc5565b9998505050505050505050565b806001600160801b038116811461328d57600080fd5b919050565b60006a636f6e736f6c652e6c6f679050600080835160208501845afa505050565b6001600160a01b038116811461306157600080fd5b8060020b811461306157600080fd5b6000806000606084860312156132ec57600080fd5b83356132f7816132b3565b92506020840135613307816132c8565b91506040840135613317816132c8565b809150509250925092565b801515811461306157600080fd5b60008060006060848603121561334557600080fd5b8335613350816132b3565b9250602084013561336081613322565b929592945050506040919091013590565b6001600160a01b0391909116815260200190565b6000806000806080858703121561339b57600080fd5b84356133a6816132b3565b93506020850135925060408501356133bd816132c8565b915060608501356133cd816132c8565b939692955090935050565b803563ffffffff8116811461328d57600080fd5b600080600080600060a0868803121561340457600080fd5b853561340f816132b3565b945060208601359350613424604087016133d8565b92506060860135613434816132b3565b91506080860135613444816132b3565b809150509295509295909350565b600060a0828403121561346457600080fd5b50919050565b60006060828403121561346457600080fd5b60008083601f84011261348e57600080fd5b5081356001600160401b038111156134a557600080fd5b6020830191508360208285010111156134bd57600080fd5b9250929050565b600080600080600061014086880312156134dd57600080fd5b85356134e8816132b3565b94506134f78760208801613452565b93506135068760c0880161346a565b92506101208601356001600160401b0381111561352257600080fd5b61352e8882890161347c565b969995985093965092949392505050565b600080600080600080610160878903121561355957600080fd5b8635613564816132b3565b95506135738860208901613452565b94506135828860c0890161346a565b935061012087013592506101408701356001600160401b038111156135a657600080fd5b6135b289828a0161347c565b979a9699509497509295939492505050565b600080600080600061010086880312156135dd57600080fd5b85356135e8816132b3565b94506135f78760208801613452565b935060c0860135613607816132b3565b925060e08601356001600160401b0381111561352257600080fd5b60006020828403121561363457600080fd5b610c7b826133d8565b60006020828403121561364f57600080fd5b8135610c7b816132b3565b6000806000806060858703121561367057600080fd5b613679856133d8565b93506020850135925060408501356001600160401b0381111561369b57600080fd5b6136a78782880161347c565b95989497509550505050565b60006101008201905082511515825260208301511515602083015260408301511515604083015260608301511515606083015260808301516136f9608084018215159052565b5060a083015161370d60a084018215159052565b5060c083015161372160c084018215159052565b5060e083015161373560e084018215159052565b5092915050565b6000806040838503121561374f57600080fd5b823591506020830135613761816132b3565b809150509250929050565b600080600080600080610120878903121561378657600080fd5b8635613791816132b3565b95506137a08860208901613452565b945060c08701356137b0816132b3565b935060e08701356137c0816132c8565b92506101008701356001600160401b038111156135a657600080fd5b600080602083850312156137ef57600080fd5b82356001600160401b0381111561380557600080fd5b6138118582860161347c565b90969095509350505050565b60005b83811015613838578181015183820152602001613820565b50506000910152565b6000815180845261385981602086016020860161381d565b601f01601f19169290920160200192915050565b602081526000610c7b6020830184613841565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b03811182821017156138be576138be613880565b604052919050565b60006001600160401b038211156138df576138df613880565b5060051b60200190565b600082601f8301126138fa57600080fd5b8135602061390f61390a836138c6565b613896565b82815260059290921b8401810191818101908684111561392e57600080fd5b8286015b8481101561395057613943816133d8565b8352918301918301613932565b509695505050505050565b6000806000806080858703121561397157600080fd5b84359350602080860135935060408601356001600160401b038082111561399757600080fd5b818801915088601f8301126139ab57600080fd5b81356139b961390a826138c6565b81815260059190911b8301840190848101908b8311156139d857600080fd5b938501935b828510156139ff5784356139f0816132b3565b825293850193908501906139dd565b965050506060880135925080831115613a1757600080fd5b5050613a25878288016138e9565b91505092959194509250565b6000806000806000806101208789031215613a4b57600080fd5b8635613a56816132b3565b9550613a658860208901613452565b945060c0870135935060e087013592506101008701356001600160401b038111156135a657600080fd5b600060208284031215613aa157600080fd5b5035919050565b600082601f830112613ab957600080fd5b81356001600160401b03811115613ad257613ad2613880565b613ae5601f8201601f1916602001613896565b818152846020838601011115613afa57600080fd5b816020850160208301376000918101602001919091529392505050565b600080600060608486031215613b2c57600080fd5b8335613b37816132b3565b92506020840135613b47816132b3565b915060408401356001600160401b03811115613b6257600080fd5b613b6e86828701613aa8565b9150509250925092565b600080600060608486031215613b8d57600080fd5b833592506020840135915060408401356001600160401b03811115613bb157600080fd5b613b6e868287016138e9565b634e487b7160e01b600052601160045260246000fd5b8082018082111561228b5761228b613bbd565b80546001600160a01b0390811683526001820154808216602085015260a081901c62ffffff16604085015260b81c600290810b60608501529091015416608090910152565b6101008101613c3a8287613be6565b8460020b60a08301528360020b60c08301528260e083015295945050505050565b8051600f81900b811461328d57600080fd5b60008060408385031215613c8057600080fd5b613c8983613c5b565b9150613c9760208401613c5b565b90509250929050565b6000600f82900b6001607f1b8101613cba57613cba613bbd565b60000392915050565b6001600160801b0391909116815260200190565b600060208284031215613ce957600080fd5b5051919050565b6101208101613cff8286613be6565b8351151560a0830152602084015160c08301526040909301516001600160a01b031660e08201526101000152919050565b60008060408385031215613d4357600080fd5b505080516020909101519092909150565b8181038181111561228b5761228b613bbd565b6101208101613d768286613be6565b8351600290810b60a08401526020850151900b60c083015260409093015160e08201526101000152919050565b6000600160ff1b8201613db857613db8613bbd565b5060000390565b606081526000613dd26060830186613841565b60ff949094166020830152506001600160a01b0391909116604090910152919050565b63ffffffff841681528260208201526060604082015260006117996060830184613841565b93845263ffffffff92909216602084015260408301526001600160a01b0316606082015260800190565b63ffffffff82811682821603908082111561373557613735613bbd565b62ffffff818116838216028082169190828114613e8057613e80613bbd565b505092915050565b634e487b7160e01b600052601260045260246000fd5b600062ffffff80841680613eb457613eb4613e88565b92169190910492915050565b62ffffff81811683821601908082111561373557613735613bbd565b600060018201613eee57613eee613bbd565b5060010190565b600080600060608486031215613f0a57600080fd5b83356001600160401b03811115613f2057600080fd5b613f2c86828701613aa8565b935050602084013560ff81168114613f4357600080fd5b91506040840135613317816132b3565b600080600060608486031215613f6857600080fd5b835192506020840151613f7a816132b3565b6040850151909250613317816132b3565b6101008101613f9a8287613be6565b8460a08301528360c08301528260e083015295945050505050565b8183823760009101908152919050565b808202811582820484141761228b5761228b613bbd565b634e487b7160e01b600052603260045260246000fd5b600060018060a01b0380865116835280602087015116602084015262ffffff6040870151166040840152606086015160020b606084015280608087015116608084015280851660a08401525060e060c083015261179960e0830184613841565b60006020828403121561406457600080fd5b8151610c7b816132c8565b6000825161408181846020870161381d565b9190910192915050565b60006020828403121561409d57600080fd5b8151610c7b81613322565b6040815260006140bb6040830185613841565b90508260208301529392505050565b60008160020b627fffff198103613cba57613cba613bbd565b6000826140f2576140f2613e88565b500490565b60008261410657614106613e88565b500690565b6001600160a01b0382811682821603908082111561373557613735613bbd565b828152604060208201526000612f23604083018461384156fea2646970667358221220327d906970be24f906e9164f481f11e15585ef386119173aafc26ccf78988b5064736f6c63430008140033a2646970667358221220d3b96c9ae21e71914f3fd96cbf5b62fdf275c655a8519d55a463984970c7d6bd64736f6c63430008140033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 12449,
        "contract": "contracts/Hooks/Utils/HooksFactory.sol:UniswapHooksFactory",
        "label": "hooks",
        "offset": 0,
        "slot": "0",
        "type": "t_array(t_address)dyn_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "base": "t_address",
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32"
      }
    }
  }
}